;+
; NAME:
;   EXOFAST_CHI2
;
; PURPOSE: 
;   Computes the chi2 for a transit and/or RV for a single planet
;
; CALLING SEQUENCE:
;    chi2 = exofast_chi2v2(pars)
;
; INPUTS:
;
;    PARS - An array of parameters that describes the model. There
;           should be one for each parameter in the structure where
;           fit==true. This array should be generated by str2pars.pro.
;
; OPTIONAL INPUTS:
; 
;    PSNAME      - If specified, this routine will generate
;                  postscript figure for each model generated with a
;                  base of PSNAME. 
;
; OPTIONAL OUTPUTS:
;    
;    DETERMINANT - The determinant of the Jacobian to weight the
;                  acceptance likelihood in order to impose
;                  non-uniform priors in the stepping parameters. This
;                  is equal to 1 (no transformation) unless MIST
;                  models are used. If MIST models are used,
;                  DETERMINANT is equal to d(EEP)/d(Age) to transform
;                  the uniform EEP prior into a uniform Age prior.
;    MODELRV     - The RV model given the parameters
;    MODELFLUX   - The Transit model given the parameters
;    DERIVED     - An array of derived parameters. Nothing is ever
;                  returned in DERIVED, but this keyword is required
;                  by EXOFAST_DEMC.
;
; RESULT:
;    The chi^2 of the model given the data and parameters.
;
; COMMON BLOCKS:
;   CHI2_BLOCK - See exofastv2.pro for definition
;
; MODIFICATION HISTORY
; 
;  2018/03 -- Create documentation -- Jason Eastman (CfA)
;-

function exofast_chi2v2, pars, determinant=determinant, $
                         modelrv=modelrv, modelflux=modelflux, psname=psname, $
                         derived=derived, loadss=loadss, ss0=ss0

COMMON chi2_block, ss

;; populate the structure with the new parameters
if keyword_set(loadss) then begin
   ss = ss0
   return, -1
endif

;; this is just a time sink for debugging/evaluating multithreading
;; ss.delay should never be > 0 in production code!!
;for i=0L, 2.5d6 do t = i ;; this takes 0.05 seconds on my machine
;for i=0L, 2.5d7 do t = i ;; this takes 0.5 seconds on my machine
for i=0L, ss.delay do t = i 

if n_elements(pars) ne 0 then pars2str, pars, ss

au = ss.constants.au/ss.constants.rsun

;; derive all required parameters 
;; (this may change depending on parameterization)
;derivepars, ss

;; initialize the determinant and chi^2
chi2 = 0.d0
determinant = 1d0

;; if values are linked, we must propagate them before we check boundaries
;; if value is a map, and the variable is fixed, we must propagate it here
for i=0L, n_elements(*ss.priors)-1 do begin

   ;; Skip priors with penalties -- the penalties will guide them to agree
   prior = (*ss.priors)[i]

   ;; if it's not fixed to a linked parameter, skip it. The penalties will sort it out
   if prior.gaussian_width ne 0d0 or prior.value[1] eq -1 then continue
   
   ;; the prior is linked to another variable -- get its value
   if prior.value[4] ne -1 then begin
      value = (*ss.(prior.value[0])[prior.value[1]].(prior.value[2])[prior.value[3]]).(prior.value[4])[prior.value[5]].value
      label = (*ss.(prior.value[0])[prior.value[1]].(prior.value[2])[prior.value[3]]).(prior.value[4])[prior.value[5]].label
   endif else if prior.value[2] ne -1 then begin
      value = ss.(prior.value[0])[prior.value[1]].(prior.value[2])[prior.value[3]].value
      label = ss.(prior.value[0])[prior.value[1]].(prior.value[2])[prior.value[3]].label
   endif else begin
      value = ss.(prior.value[0])[prior.value[1]].value
      label = ss.(prior.value[0])[prior.value[1]].label
   endelse

   ;; assign the value
   if prior.map[4] ne -1 then begin
      (*ss.(prior.map[0])[prior.map[1]].(prior.map[2])[prior.map[3]]).(prior.map[4])[prior.map[5]].value = value
   endif else if prior.map[2] ne -1 then begin
      ss.(prior.map[0])[prior.map[1]].(prior.map[2])[prior.map[3]].value = value
   endif else if prior.map[0] ne -1 then begin
      ss.(prior.map[0])[prior.map[1]].value = value
   endif     

   if ss.verbose then printandlog, $
      'linking ' + prior.name + ' to ' + label
   
endfor



;; *** First make sure step parameters are in bounds ***

;; physical limb darkening (Kipping, 2013)
;; http://adsabs.harvard.edu/abs/2013MNRAS.435.2152K, eq 8
if (where(ss.planet.fittran))[0] ne -1 then begin
   bad = where(ss.band.u1.value + ss.band.u2.value gt 1d0 or $
               ss.band.u1.value lt 0d0 or $
               ss.band.u1.value + 2d0*ss.band.u2.value lt 0d0, nbad)
   if nbad gt 0 then begin
      if ss.debug or ss.verbose then printandlog, $
         strtrim(nbad,2) + ' limb darkening parameters are bad (' + strtrim(ss.band[bad[0]].u1.value,2) + ', ' + strtrim(ss.band[bad[0]].u2.value,2) + ')',ss.logname
      return, !values.d_infinity
   endif
endif

;; -180 < phase shift < 180
bad = where(abs(ss.band.phaseshift.value) gt 180d0,nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'phase shift is bad (' + strtrim(bad,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; 0.1 < Period < 10^13 (~age of the universe)
bad = where(ss.planet.logp.value gt 13d0 or ss.planet.logp.value lt -1d0,nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'logP is bad (' + strtrim(bad,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; -max(period)/2 < ttv < max(period)/2
bad = where(abs(ss.transit.ttv.value) gt max(ss.planet.period.value)/2d0,nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'ttv is bad (' + strtrim(ss.transit[bad].ttv.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; older than the universe (too conservative?)
bad = where(ss.star.age.value gt 13.82d0 or ss.star.age.value lt 0d0, nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'age is bad (' + strtrim(ss.star[bad].age.value,2) +')',ss.logname
   return, !values.d_infinity
endif

;; positive extinction
bad = where(ss.star.av.value lt 0 or ss.star.av.value gt 1d3, nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'extinction is bad (' + strtrim(ss.star[bad].av.value,2) + ')',ss.logname
   return, !values.d_infinity
endif

;; can't have more than +/-100% dilution
;bad = where(ss.band.dilute.fit and (ss.band.dilute.value le -1d0 or ss.band.dilute.value ge 1d0),nbad)
bad = where(ss.transit.dilute.fit and (ss.transit.dilute.value le -1d0 or ss.transit.dilute.value ge 1d0),nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'dilution is bad (' + strtrim(ss.transit[bad].dilute.value,2) + ')',ss.logname
   return, !values.d_infinity
endif

;; 0.9 AU to the size of the universe
bad = where(ss.star.distance.value lt 4d-6 or ss.star.distance.value gt 3d10,nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'distance is bad (' + strtrim(ss.star[bad].distance.value,2) + ')',ss.logname
   return, !values.d_infinity
endif

;; check vcve
bad = where(ss.planet.vcve.value lt 0, nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'vcve is bad (' + strtrim(ss.planet[bad].vcve.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; check sign
bad = where(ss.planet.sign.value lt 0 or ss.planet.sign.value ge 2 or ss.planet.sign2.value lt 0 or ss.planet.sign2.value ge 2, nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'sign is bad (' + strtrim(ss.planet[bad].sign.value,2) + ')', ss.logname
   return, !values.d_infinity
endif 

;; Omega boundary checking
bad = where(ss.planet.lsinbigomega.value^2 + ss.planet.lsinbigomega.value^2 gt 1d0, nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'bigomega is bad', ss.logname
   return, !values.d_infinity
endif

;; limit 0 < Omega < 180 if RVs or Transits not fit
bad = where((ss.planet.lsinbigomega.value lt 0d0 or ss.planet.lcosbigomega.value lt 0d0) and (ss.fitrv or ss.fittran), nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'bigomega is bad', ss.logname
   return, !values.d_infinity
endif

;; lambda boundary checking
bad = where(ss.planet.lsinlambda.value^2 + ss.planet.lcoslambda.value^2 gt 1d0, nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'lambda is bad', ss.logname
   return, !values.d_infinity
endif

;; ramp boundary checking
rampfit = where(ss.transit.rampexp.fit)
if rampfit[0] ne -1 then begin
   for i=0L, n_elements(rampfit)-1 do begin
      transit = *(ss.transit[rampfit[i]].transitptrs)
      if ss.transit[rampfit[i]].rampexp.value le 0d0 or ss.transit[rampfit[i]].rampexp.value gt transit.timerange*10d0 then begin
         if ss.debug or ss.verbose then printandlog, 'rampexp ' + strtrim(rampfit[i],2) + ' is bad (' + strtrim(ss.transit[rampfit[i]].rampexp.value,2) + ')', ss.logname
         return, !values.d_infinity
      endif
   endfor
endif

;; -c < gamma < c
bad = where(abs(ss.telescope.gamma.value) gt ss.constants.c/ss.constants.meter,nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'gamma is bad (' + strtrim(ss.telescope[bad].gamma.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; excludes non-transiting planets where the transit is fit
;; NOTE: chord is not derived by step2pars, only check if chord is fit
bad = where((ss.planet.chord.value le 0d0 or ss.planet.chord.value gt (1d0+ss.planet.p.value)) and ss.planet.chord.fit,nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'chord is bad (' + strtrim(bad,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; -c^2 < jitter^2 < c^2
bad = where(abs(ss.telescope.jittervar.value) gt (ss.constants.c/ss.constants.meter)^2,nbad)
if nbad gt 0 then begin
   if ss.debug  or ss.verbose then printandlog, 'jittervar is bad (' + strtrim(ss.telescope[bad].jittervar.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; abs(slope) < 1d5 m/s/day
bad = where(abs(ss.star.slope.value) gt 1d5,nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'slope is bad (' + strtrim(ss.star[bad].slope.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; abs(quad) < 1d5 m/s/day^2
bad = where(abs(ss.star.quad.value) gt 1d5,nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'quad is bad (' + strtrim(ss.star[bad].quad.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; 0.01 < SED error scaling < 100
bad = where(ss.star.errscale.value lt 1d-2 or ss.star.errscale.value gt 1d2, nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'error scale is bad (' + strtrim(ss.star[bad].errscale.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; 0.01 < Specphot error scaling < 10000
bad = where(ss.specphot.sperrscale.value lt 1d-2 or ss.specphot.sperrscale.value gt 1d5, nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'spectrophotometry error scale is bad (' + strtrim(ss.specphot[bad].sperrscale.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; -0.2 < spzeropoint < 0.2
;bad = where(ss.specphot.spzeropoint.value lt -0.3d0 or ss.specphot.spzeropoint.value gt 0.3d0, nbad)
bad = where(ss.specphot.spzeropoint.value lt -0.999d0 or ss.specphot.spzeropoint.value gt 999d0, nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'spectrophotometry zero point is bad (' + strtrim(ss.specphot[bad].spzeropoint.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; -10 < [Fe/H] < 2 
bad = where(ss.star.feh.value lt -10d0 or ss.star.feh.value gt 2d0 ,nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'teff is bad (' + strtrim(ss.star[bad].teff.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; 100 < Teff < 50000
bad = where(ss.star.teff.value lt 100 or ss.star.teff.value gt 250000,nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'teff is bad (' + strtrim(ss.star[bad].teff.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; 100 < Teff < 50000 
bad = where(ss.star.teffsed.value lt 100 or ss.star.teffsed.value gt 250000,nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'teffsed is bad (' + strtrim(ss.star[bad].teffsed.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; 10^-6 < rstar < 2000
bad = where(ss.star.rstar.value lt 1d-6 or ss.star.rstar.value gt 2000d0,nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'rstar is bad (' + strtrim(ss.star[bad].rstar.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; 10^-6 < rstar < 2000
bad = where(ss.star.rstarsed.value lt 1d-6 or ss.star.rstarsed.value gt 2000d0,nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'rstarsed is bad (' + strtrim(ss.star[bad].rstar.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; 10^-3 < mstar < 500
bad = where(ss.star.logmstar.value lt -3 or ss.star.logmstar.value gt 2.6989700d0,nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'mstar is bad (' + strtrim(ss.star[bad].mstar.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; bound marginally detected planets to limit (infinite) parameter space at low logmp
;; conservative lower limit of 1 Ceres in 1 year orbit around sun = 10 um/s
;; conservative upper limit corresponds to 500 solar masses (larger
;; than the largest known star)
bad = where((ss.planet.logmp.value lt -9.4d0 or ss.planet.logmp.value gt 2.7d0) and ss.planet.logmp.fit, nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'logmp is bad (' + strtrim(ss.planet[bad].logmp.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

if ss.nastrom gt 0 then begin
   ;; 0.01 < astrometric error scaling < 100
   bad = where(ss.astrom.astromscale.value lt 1d-2 or ss.astrom.astromscale.value  gt 1d2, nbad)
   if nbad gt 0 then begin
      if ss.debug or ss.verbose then printandlog, 'astrometry error scale is bad (' + strtrim(ss.astrom[bad].errscale.value,2) + ')', ss.logname
      return, !values.d_infinity
   endif

   ;; 0 <= ra+raoffset <= 360
   bad = where(ss.star[ss.astrom.starndx].ra.value + ss.astrom.raoffset.value lt 0 or ss.star[ss.astrom.starndx].ra.value + ss.astrom.raoffset.value gt 360,nbad)
   if nbad gt 0 then begin
      if ss.debug or ss.verbose then printandlog, 'ra is bad (' + strtrim(ss.star[ss.astrom.starndx].ra.value,2) + ')', ss.logname
      return, !values.d_infinity
   endif
   
   ;; -90 <= dec+decoffset <= 90
   bad = where(abs(ss.star[ss.astrom.starndx].dec.value + ss.astrom.decoffset.value) gt 90,nbad)
   if nbad gt 0 then begin
      if ss.debug or ss.verbose then printandlog, 'dec is bad (' + strtrim(ss.star[ss.astrom.starndx].dec.value +ss.astrom[bad].decoffset.value,2) + ')', ss.logname
      return, !values.d_infinity
   endif
   
   ;; -20000 <= pmra <= 20000 (2x barnard's star)
   if abs(ss.star[ss.astrom.starndx].pmra.value) gt 2d4 then begin
      if ss.debug or ss.verbose then printandlog, 'pmra is bad (' + strtrim(ss.star[ss.astrom.starndx].pmra.value,2) + ')', ss.logname
      return, !values.d_infinity
   endif

   ;; -20000 <= pmdec <= 20000 (2x barnard's star)
   if abs(ss.star[ss.astrom.starndx].pmdec.value) gt 2d4 then begin
      if ss.debug or ss.verbose then printandlog, 'pmdec is bad (' + strtrim(ss.star[ss.astrom.starndx].pmdec.value,2) + ')', ss.logname
      return, !values.d_infinity
   endif
   
   ;; -c <= rvabs <= c 
   if abs(ss.star[ss.astrom.starndx].rvabs.value) gt ss.constants.c/ss.constants.meter then begin
      if ss.debug or ss.verbose then printandlog, 'pmdec is bad (' + strtrim(ss.star[ss.astrom.starndx].pmdec.value,2) + ')', ss.logname
      return, !values.d_infinity
   endif
   
endif

;; 0.01 < DT error scaling < 100
bad = where(ss.doptom.dtscale.value le 1d-2 or ss.doptom.dtscale.value gt 1d2, nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'dtscale is bad (' + strtrim(ss.doptom[bad].dtscale.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; limit range of alpha abundance (not used yet)
;bad = where(ss.star.alpha.value lt -0.3d0 or ss.star.alpha.value gt 0.7d0,nbad) 
;if nbad gt 0 then begin
;   if ss.debug or ss.verbose then printandlog, 'alpha is bad (' + strtrim(ss.star[bad].alpha.value,2) + ')', ss.logname
;   return, !values.d_infinity
;endif

;; require planets to stay in the same order as they start
if ss.nplanets gt 0 then begin
   if max(abs(ss.planetorder - sort(ss.planet.logp.value))) ne 0 then begin
      if keyword_set(ss.verbose) then printandlog, 'Planets must remain in the original order! Rejecting step', logname
      return, !values.d_infinity
   endif
endif

;; **** Now place additional physical constraints on derived parameters ****

;; derive the model parameters from the step parameters
;; (returns -1 if can't be derived due to non-physical inputs)
if step2pars(ss,verbose=(ss.debug or ss.verbose),logname=ss.logname) eq -1 then begin
   if ss.debug or ss.verbose then printandlog, 'stellar system is bad', ss.logname
   return, !values.d_infinity
endif

;; check angular parameters
;; omega boundary checking
bad = where(ss.planet.lsinw.value^2 + ss.planet.lcosw.value^2 gt 1d0, nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'omega is bad', ss.logname
   return, !values.d_infinity
endif

;; tighter (empirical) constraint on eccentricity (see Eastman 2013)
if ss.tides then begin
   bad = where(ss.planet.e.value gt (1d0-3d0/ss.planet.ar.value), nbad)
   if nbad ne 0 then begin
      if ss.verbose then $
         printandlog, 'TIDES flag set and eccentricity (' + strtrim(ss.planet[bad].e.value,2) + $
                   ') exceeds empirical limit (' + strtrim((1d0-3d0/ss.planet[bad].ar.value),2) + ')', ss.logname
      return, !values.d_infinity
   endif
endif

;; no transit and we're fitting a transit! This causes major
;; problems; exclude this model (but this biases the significance of
;; the detection)
bad = where(~ss.noprimary and ss.fittran and ss.planet.b.value gt (1d0+ss.planet.p.value), nbad)
if nbad ne 0L then begin
   if ss.verbose then printandlog, 'Planet ' + strtrim(bad,2) + ' has no primary transit!', ss.logname
   return, !values.d_infinity
endif

bad = where(ss.requiresecondary and ss.planet.bs.value gt (1d0+ss.planet.p.value), nbad)
if nbad ne 0L then begin
   if ss.verbose then printandlog, 'Planet ' + strtrim(bad,2) + ' has no secondary eclipse!', ss.logname
   return, !values.d_infinity
endif

;; for multi-planet systems, make sure they don't enter each other's hill spheres
;; if mp unknown, mp=0 => hill radius=0 => planets can't cross orbits
;; **** ignores mutual inclination; a priori excludes systems like
;; Neptune and Pluto!! ****

if ~ss.alloworbitcrossing then begin
   mindist = dblarr(ss.nplanets>1)
   maxdist = dblarr(ss.nplanets>1)
   for i=0L, ss.nplanets-1 do begin
      hillradius = ((1d0-ss.planet[i].e.value)*ss.planet[i].a.value*(ss.planet[i].mpsun.value/(3d0*ss.star[ss.planet[i].starndx].mstar.value))^(1d0/3d0)) > 0d0
      mindist[i] = (1d0-ss.planet[i].e.value)*ss.planet[i].a.value - hillradius
      maxdist[i] = (1d0+ss.planet[i].e.value)*ss.planet[i].a.value + hillradius
      for j=i-1,0,-1 do begin
         if ((mindist[i] ge mindist[j]) and (mindist[i] le maxdist[j])) or $
            ((maxdist[i] ge mindist[j]) and (maxdist[i] le maxdist[j])) or $
            ((mindist[j] ge mindist[i]) and (mindist[j] le maxdist[i])) or $
            ((maxdist[j] ge mindist[i]) and (maxdist[j] le maxdist[i])) then begin
            if ss.verbose then printandlog, 'Planets ' + strtrim(j,2) + ' (' + strtrim(mindist[j],2) + ',' + strtrim(maxdist[j],2) + ') and ' + strtrim(i,2) + ' (' + strtrim(mindist[i],2) + ',' + strtrim(maxdist[i],2) + ') cross paths', logname
            return, !values.d_infinity
         endif
      endfor
   endfor
endif

;; must do after step2pars -- sometimes tt is derived
;; tt-period/2 < tt < tt+period/2
bad = where(ss.planet.tt.prior ne 0d0 and $
            abs(ss.planet.tt.value - ss.planet.tt.prior) gt ss.planet.period.value/2d0,nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'tt is bad (' + strtrim(ss.planet[bad].tt.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; must do after step2pars -- sometimes tc is derived
;; tc-period/2 < tc < tc+period/2
bad = where(ss.planet.tc.prior ne 0d0 and $
            abs(ss.planet.tc.value - ss.planet.tc.prior) gt ss.planet.period.value/2d0,nbad)
if nbad gt 0 and ss.nplanets gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'tc is bad (' + strtrim(ss.planet[bad].tc.value,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; must do after step2pars -- sometimes cosi is derived
;; 0 <= cosi <= 1 (or -1 <= cosi <= 1 if i180 keyword set or astrometry fit)
bad = where(ss.planet.cosi.value gt 1 or (ss.planet.cosi.value lt 0 and ~ss.planet.i180) or (ss.planet.cosi.value lt -1),nbad)
if nbad gt 0 then begin
   if ss.debug or ss.verbose then printandlog, 'cosi is bad (' + strtrim(bad,2) + ')', ss.logname
   return, !values.d_infinity
endif

;; *** Now start penalizing the model ***

;; ****************** apply priors ***************************
for i=0L, n_elements(*ss.priors)-1 do begin
   
   prior = (*ss.priors)[i]
   
   ;; get the model value
   if prior.map[4] ne -1 then begin
      model_value = (*ss.(prior.map[0])[prior.map[1]].(prior.map[2])[prior.map[3]]).(prior.map[4])[prior.map[5]].value
      unit = strupcase((*ss.(prior.map[0])[prior.map[1]].(prior.map[2])[prior.map[3]]).(prior.map[4])[prior.map[5]].unit)
      label = (*ss.(prior.map[0])[prior.map[1]].(prior.map[2])[prior.map[3]]).(prior.map[4])[prior.map[5]].label
   endif else if prior.map[2] ne -1 then begin
      model_value = ss.(prior.map[0])[prior.map[1]].(prior.map[2])[prior.map[3]].value
      unit = strupcase(ss.(prior.map[0])[prior.map[1]].(prior.map[2])[prior.map[3]].unit)
      label = ss.(prior.map[0])[prior.map[1]].(prior.map[2])[prior.map[3]].label
   endif else if prior.map[0] ne -1 then begin
      model_value = ss.(prior.map[0])[prior.map[1]].value
      unit = strupcase(ss.(prior.map[0])[prior.map[1]].unit)
      label = ss.(prior.map[0])[prior.map[1]].label
   endif

   ; skip vsini penalty, we will apply it later
   if label eq 'vsini' then continue

   ;; get the prior value
   if prior.value[1] ne -1 then begin
      ;; this is a link to another variable
      if prior.value[4] ne -1 then begin
         prior_value = (*ss.(prior.value[0])[prior.value[1]].(prior.value[2])[prior.value[3]]).(prior.value[4])[prior.value[5]].value
      endif else if prior.value[2] ne -1 then begin
         prior_value = ss.(prior.value[0])[prior.value[1]].(prior.value[2])[prior.value[3]].value
      endif else begin
         prior_value = ss.(prior.value[0])[prior.value[1]].value
      endelse
      ;; uniform bounds are relative to the other variable
      lowerbound = prior_value + prior.lowerbound
      upperbound = prior_value + prior.upperbound
   endif else begin
      ;; this is a direct prior
      prior_value = prior.value[0]
      lowerbound = prior.lowerbound
      upperbound = prior.upperbound
   endelse
   
   ;; if it's a (periodic) time, make sure we propagate to the right epoch
   if prior.name eq 'tc' then begin
      period = ss.(prior.map[0])[prior.map[1]].period[prior.map[3]].value
      time0 = ss.(prior.map[0])[prior.map[1]].tc[prior.map[3]].value
      nper = round((prior_value-time0)/period)
      prior_value = prior_value + nper*period
      upperbound = upperbound + nper*period
      lowerbound = lowerbound + nper*period
   endif else if prior.name eq 'tt' then begin
      period = ss.(prior.map[0])[prior.map[1]].period[prior.map[3]].value
      time0 = ss.(prior.map[0])[prior.map[1]].tt[prior.map[3]].value
      nper = round((prior_value-time0)/period)
      prior_value = prior_value + nper*period
      upperbound = upperbound + nper*period
      lowerbound = lowerbound + nper*period
   endif else if prior.name eq 'ts' then begin
      period = ss.(prior.map[0])[prior.map[1]].period[prior.map[3]].value
      time0 = ss.(prior.map[0])[prior.map[1]].ts[prior.map[3]].value
      nper = round((prior_value-time0)/period)
      prior_value = prior_value + nper*period
      upperbound = upperbound + nper*period
      lowerbound = lowerbound + nper*period
   endif else if prior.name eq 't0' then begin
      period = ss.(prior.map[0])[prior.map[1]].period[prior.map[3]].value
      time0 = ss.(prior.map[0])[prior.map[1]].t0[prior.map[3]].value
      nper = round((prior_value-time0)/period)
      prior_value = prior_value + nper*period
      upperbound = upperbound + nper*period
      lowerbound = lowerbound + nper*period
   endif else if prior.name eq 'tp' then begin
      period = ss.(prior.map[0])[prior.map[1]].period[prior.map[3]].value
      time0 = ss.(prior.map[0])[prior.map[1]].tp[prior.map[3]].value
      nper = round((prior_value-time0)/period)
      prior_value = prior_value + nper*period
      upperbound = upperbound + nper*period
      lowerbound = lowerbound + nper*period
   endif else if prior.name eq 'td' then begin
      period = ss.(prior.map[0])[prior.map[1]].period[prior.map[3]].value
      time0 = ss.(prior.map[0])[prior.map[1]].td[prior.map[3]].value
      nper = round((prior_value-time0)/period)
      prior_value = prior_value + nper*period
      upperbound = upperbound + nper*period
      lowerbound = lowerbound + nper*period
   endif else if prior.name eq 'ta' then begin
      period = ss.(prior.map[0])[prior.map[1]].period[prior.map[3]].value
      time0 = ss.(prior.map[0])[prior.map[1]].ta[prior.map[3]].value
      nper = round((prior_value-time0)/period)
      prior_value = prior_value + nper*period
      upperbound = upperbound + nper*period
      lowerbound = lowerbound + nper*period
   endif 

   if model_value gt upperbound or model_value lt lowerbound then begin
      if ss.debug or ss.verbose then $
         printandlog, label + '( ' + strtrim(model_value,2) + ') is out of user-defined bounds (' +$
                      strtrim(lowerbound,2) + ',' + strtrim(upperbound,2) + ')',ss.logname      
      return, !values.d_infinity
   endif

   ;; no gaussian prior, skip
   if prior.gaussian_width le 0d0 then continue

   ;; if it's an angular parameter, make sure we handle the boundary
   if unit eq 'RADIANS' then begin
      priorchi2 = (atan(sin(model_value-prior_value),cos(model_value-prior_value))/prior.gaussian_width)^2
   endif else if unit eq 'DEGREES' then begin
      priorchi2 = (atan(sin((model_value-prior_value)*!dpi/180d0),cos((model_value-prior_value)*!dpi/180d0))/(prior.gaussian_width*!dpi/180d0))^2
   endif else begin
      priorchi2 = ((model_value - prior_value)/prior.gaussian_width)^2
   endelse

   ;; output debugging info if requested
   if ss.verbose then begin
      str = string(label,priorchi2,model_value,prior_value,prior.gaussian_width, $
                   format='(a," penalty = ",f0.6," (model value=",f0.6,", prior value=",f0.6,", gaussian width=",f0.6,")")')
      printandlog, str, ss.logname
   endif

   chi2 += priorchi2

endfor
;; ******************************************************************

if 0 then begin
priors = *(ss.priors)
for i=0, n_elements(priors[0,*])-1 do begin
   
   ;; if it's not a detrending variable
   if priors[3,i] eq -1 then begin
      value = ss.(priors[0,i])[priors[1,i]].(priors[2,i]).value
      upperbound = ss.(priors[0,i])[priors[1,i]].(priors[2,i]).upperbound
      lowerbound =  ss.(priors[0,i])[priors[1,i]].(priors[2,i]).lowerbound 
      label =  ss.(priors[0,i])[priors[1,i]].(priors[2,i]).label + '_' + strtrim(priors[1,i],2)
      prior =  ss.(priors[0,i])[priors[1,i]].(priors[2,i]).prior
      priorwidth = ss.(priors[0,i])[priors[1,i]].(priors[2,i]).priorwidth
      unit = strupcase(ss.(priors[0,i])[priors[1,i]].(priors[2,i]).unit)
   endif else begin
      ;; otherwise
      value = (*(ss.(priors[0,i])[priors[1,i]].(priors[2,i]))).(priors[3,i])[priors[4,i]].value
      upperbound = (*(ss.(priors[0,i])[priors[1,i]].(priors[2,i]))).(priors[3,i])[priors[4,i]].upperbound
      lowerbound = (*(ss.(priors[0,i])[priors[1,i]].(priors[2,i]))).(priors[3,i])[priors[4,i]].lowerbound 
      label =  (*(ss.(priors[0,i])[priors[1,i]].(priors[2,i]))).(priors[3,i])[priors[4,i]].label + '_' + strtrim(priors[1,i],2)
      prior = (*(ss.(priors[0,i])[priors[1,i]].(priors[2,i]))).(priors[3,i])[priors[4,i]].prior
      priorwidth = (*(ss.(priors[0,i])[priors[1,i]].(priors[2,i]))).(priors[3,i])[priors[4,i]].priorwidth
      unit = strupcase((*(ss.(priors[0,i])[priors[1,i]].(priors[2,i]))).(priors[3,i])[priors[4,i]].unit)
   endelse 
   
   ;; apply the bounds
   if value gt upperbound or value lt lowerbound then begin
      if ss.debug or ss.verbose then $
         printandlog, label + '( ' + strtrim(value,2) + ') is out of user-defined bounds (' +$
                      strtrim(lowerbound,2) + ',' + strtrim(upperbound,2) + ')',ss.logname
      return, !values.d_infinity
   endif
   
   ;; apply the Gaussian prior
   ;; if it's an angular parameter, make sure we handle the boundary
   if unit eq 'RADIANS' then begin
      chi2 += (atan(sin(value-prior),cos(value-prior))/priorwidth)^2
   endif else if unit eq 'DEGREES' then begin
      chi2 += (atan(sin((value-prior)*!dpi/180d0),cos((value-prior)*!dpi/180d0))/(priorwidth*!dpi/180d0))^2
   endif else begin
      chi2 += ((value - prior)/priorwidth)^2
   endelse

   ;; output debugging info if requested
   if ss.verbose then begin
      str = string(label,((value - prior)/priorwidth)^2, format='(a," penalty = ",f0.6)')
      printandlog, str, ss.logname
   endif
   
endfor
endif

;; **** apply corrections to make priors physical ****

; if fitting in v_c/v_e & omega, correct for a uniform eccentricity prior
for i=0, ss.nplanets-1 do begin
   ;; vcve jacobian
   if ss.planet[i].vcve.fit then begin
      dvcvede = abs((-sin(ss.planet[i].omega.value)-ss.planet[i].e.value)/$
                    (sqrt(1d0-ss.planet[i].e.value^2)*(ss.planet[i].esinw.value+1d0)^2))
      determinant *= dvcvede
   endif

   ;; chord jacobian
   if ss.planet[i].chord.fit then begin
      dchorddcosi = ss.planet[i].b.value^2/(ss.planet[i].cosi.value*ss.planet[i].chord.value)
      determinant *= dchorddcosi
   endif

   ;; linear eccentricity prior
   ;; we never fit in ecosw & esinw; a waste of time
   ;if ss.planet[i].ecosw.fit and ss.planet[i].esinw.fit then begin
   ;   determinant *= ss.planet[i].e.value
   ;endif

endfor

;; closer stars should have lower extinction
if keyword_set(avprior) then begin
   sorted = sort(ss.star.distance.value)
   for i=1L, ss.nstars-1 do begin
      if ss.star[sorted[i]].av.value lt ss.star[sorted[i-1]].av.value then begin
         if ss.verbose then printandlog, 'Star ' + strtrim(sorted[i],2) + $
                                         ' (Av=' + strtrim(ss.star[sorted[i]].av.value,2) + $
                                         ', distance=' + strtrim(ss.star[sorted[i]].distance.value,2) + ') '+ $
                                         ' has a lower extinction than star ' + strtrim(sorted[i-1],2) + $
                                         ' (Av=' + strtrim(ss.star[sorted[i-1]].av.value,2) + $
                                         ', distance=' + strtrim(ss.star[sorted[i-1]].distance.value,2) + $
                                         ') despite being farther away. ' + $
                                         'Set /NOAVPRIOR to disable this constraint.'  
         return, !values.d_infinity
      endif
   endfor
endif

;; *** Now computing model constraints ***
for i=0L, ss.nstars-1 do begin

   ;; apply YY penalty to constrain stellar parameters
   if ss.yy[i] then begin
      
      if keyword_set(psname) then epsname = psname+'.yy.eps'
      sigmab = ss.constants.sigmab/ss.constants.lsun*ss.constants.rsun^2
      yychi2 = massradius_yy3(ss.star[i].mstar.value, ss.star[i].feh.value, $
                              ss.star[i].age.value, ss.star[i].teff.value,$
                              yyrstar=yyrstar, debug=ss.debug, psname=epsname, $
                              sigmab=sigmab,$
                              gravitysun=ss.constants.gravitysun)
      if ~finite(yychi2) then begin
         if ss.debug or ss.verbose then $
            printandlog, 'star not on YY tracks', ss.logname
         return, !values.d_infinity
      endif
      
      yychi2 += ((ss.star[i].rstar.value - yyrstar)/(0.03d0*yyrstar))^2
      chi2 += yychi2
      if ss.verbose then $
         printandlog, 'YY penalty = ' + strtrim(yychi2,2), ss.logname
   endif      

   ;; apply PARSEC penalty to constrain stellar parameters
   if ss.parsec[i] then begin
      if keyword_set(psname) then $
         epsname = psname+'.parsec.' + string(i,format='(i03)') + '.eps'

      parsecchi2 = massradius_parsec(ss.star[i].eep.value, $
                                     ss.star[i].mstar.value, $
                                     ss.star[i].initfeh.value, $
                                     ss.star[i].age.value, $
                                     ss.star[i].teff.value,$
                                     ss.star[i].rstar.value, $
                                     ss.star[i].feh.value, debug=ss.debug, $
                                     epsname=epsname, $
                                     gravitysun=ss.constants.gravitysun, $
                                     /fitage,$;=ss.star[i].age.fit, $
                                     ageweight=ageweight, $
                                     logname=ss.logname, verbose=ss.verbose,$
                                     tefffloor=ss.teffemfloor, $
                                     fehfloor=ss.fehemfloor, $
                                     rstarfloor=ss.rstaremfloor, $
                                     agefloor=ss.ageemfloor)
      
      chi2 += parsecchi2
      if ss.verbose then $
         printandlog, 'PARSEC penalty = ' + strtrim(parsecchi2,2), ss.logname
      if ~finite(chi2) then begin
         if ss.debug or ss.verbose then $
            printandlog, 'star not on PARSEC tracks', ss.logname
         return, !values.d_infinity
      endif
      determinant *= ageweight ;; correct uniform EEP prior to uniform Age prior
   endif
   
   ;; apply MIST penalty to constrain stellar parameters
   if ss.mist[i] then begin
      if keyword_set(psname) then epsname = psname + '.mist.' + string(i,format='(i03)') + '.eps'

      mistchi2 = massradius_mist(ss.star[i].eep.value, $
                                 ss.star[i].mstar.value,$
                                 ss.star[i].initfeh.value, $
                                 ss.star[i].age.value, $
                                 ss.star[i].teff.value,$
                                 ss.star[i].rstar.value, $
                                 ss.star[i].feh.value, $
                                 debug=ss.debug, $
                                 epsname=epsname, $
                                 gravitysun=ss.constants.gravitysun, $
                                 /fitage,$;=ss.star[i].age.fit, $
                                 ageweight=ageweight, $
                                 logname=ss.logname, verbose=ss.verbose,$
                                 tefffloor=ss.teffemfloor, $
                                 fehfloor=ss.fehemfloor, $
                                 rstarfloor=ss.rstaremfloor, $
                                 agefloor=ss.ageemfloor, pngname=pngname,$
                                 range=ss.emrange)

      ;; if there's more than one star with the same age and initfeh,
      ;; make an isochrone with all of them on it
      if keyword_set(psname) then begin
         match = where(ss.star.age.value eq ss.star[i].age.value and $
                       ss.star.initfeh.value eq ss.star[i].initfeh.value,nmatch)
         if nmatch gt 1 and match[0] eq i then begin
            isoname = psname + '.mistiso.' +string(i,format='(i03)') + '.eps'
            plotisochrone, ss.star[i].age.value, ss.star[i].initfeh.value,$
                           mstar=ss.star[match].mstar.value,$
                           teff=ss.star[match].teff.value,$
                           rstar=ss.star[match].rstar.value,$
                           /plotmodel,epsname=isoname
         endif
      endif
            
      chi2 += mistchi2
      if ss.verbose then $
         printandlog, 'MIST penalty = ' + strtrim(mistchi2,2), ss.logname
      if ~finite(chi2) then begin
         if ss.debug or ss.verbose then $
            printandlog, 'star not on MIST tracks', ss.logname
         return, !values.d_infinity
      endif
      determinant *= ageweight ;; correct uniform EEP prior to uniform Age prior
   endif

   ;; apply TORRES penalty to constrain stellar parameters
   if ss.torres[i] then begin
      massradius_torres, ss.star[i].logg.value, ss.star[i].teff.value, $
                         ss.star[i].feh.value, mstar_prior, rstar_prior
      umstar = 0.027d0
      urstar = 0.014d0
      if mstar_prior lt 0.6d0 then printandlog, $
         'WARNING: Torres not applicable (mstar = ' + $
         strtrim(mstar_prior,2) + '); ignore at beginning. Otherwise, ' + $
         'use MIST, YY, PARSEC, or impose a prior on mstar/rstar',ss.logname
      ;; add "prior" penalty
      chi2 += (alog10(ss.star[i].mstar.value/mstar_prior)/umstar)^2
      chi2 += (alog10(ss.star[i].rstar.value/rstar_prior)/urstar)^2
      
      if ss.verbose then begin
         mstarpenalty = (alog10(ss.star[i].mstar.value/mstar_prior)/umstar)^2
         rstarpenalty =  (alog10(ss.star[i].rstar.value/rstar_prior)/urstar)^2
         msg = 'Torres penalty: ' + string(mstarpenalty,rstarpenalty,format='(f0.6,x,f0.6)')
         printandlog, msg, ss.logname
      endif
   endif

   ;; apply MANN penalty to constrain stellar parameters
   if ss.mannrad[i] or ss.mannmass[i] then begin
      massradius_mann, ss.star[i].appks.value, mstar_prior, rstar_prior, $
                       feh=ss.star[i].feh.value, $
                       sigma_rstar=urstar, sigma_mstar=umstar,$
                       distance=ss.star[i].distance.value

      if ss.star[i].mstar.value gt 0.7d0 and ss.verbose then $
         printandlog, 'WARNING: MANN not applicable (mstar = ' + $
                      strtrim(ss.star[i].mstar.value,2) + ' > 0.7); ignore at beginning. Otherwise, ' + $
                      'use MIST, YY, PARSEC, TORRES, or impose a prior on mstar/rstar',ss.logname

      ;; add "prior" penalties
      if ss.mannrad[i] then begin
         rstarpenalty = ((ss.star[i].rstar.value - rstar_prior)/urstar)^2
         chi2 += rstarpenalty
         if ss.verbose then printandlog, 'Mann rstar penalty: ' + strtrim(rstarpenalty,2),ss.logname
      endif

      if ss.mannmass[i] then begin
         mstarpenalty = ((ss.star[i].mstar.value - mstar_prior)/umstar)^2
         chi2 += mstarpenalty
         if ss.verbose then printandlog, 'Mann mstar penalty: ' + strtrim(mstarpenalty,2),ss.logname
      endif

   endif
endfor

;; fit the SED with MIST BC tables
if file_test(ss.mistsedfile) or file_test(ss.fluxfile) or file_test(ss.sedfile) then begin
   if keyword_set(psname) then epsname = psname+'.sed.eps'

   sedchi2 = 0d0

   ;; the SED can constrain Teff too precisely
   ;; (they ignore systematics in interferimetric radii on which they're based). 
   ;; Add a floor for the Teff used everywhere else
   tofit = where(ss.star.teffsed.fit,nfit)
   teffsed = ss.star.teff.value
   if nfit gt 0 then begin
      teffsed[tofit] = ss.star[tofit].teffsed.value
      sedchi2 += total(((ss.star[tofit].teff.value - ss.star[tofit].teffsed.value)/(ss.teffsedfloor*ss.star[tofit].teffsed.value))^2)
   endif

   tofit = where(ss.star.fehsed.fit,nfit)
   fehsed = ss.star.feh.value
   if nfit gt 0 then begin
      fehsed[tofit] = ss.star[tofit].fehsed.value
      sedchi2 += total(((ss.star[tofit].feh.value - ss.star[tofit].fehsed.value)/ss.fehsedfloor)^2)
   endif

   ;; the SED can constrain FBol too precisely
   ;; Add a floor for the Fbol used everywhere else
   tofit = where(ss.star.rstarsed.fit,nfit)
   rstarsed = ss.star.rstar.value
   lstarsed = 4d0*!dpi*rstarsed^2*teffsed^4*ss.constants.sigmab/ss.constants.lsun*ss.constants.rsun^2 ;; lsun
   if nfit gt 0 then begin
      rstarsed[tofit] = ss.star[tofit].rstarsed.value
      lstarsed[tofit] = 4d0*!dpi*rstarsed^2*teffsed^4*ss.constants.sigmab/ss.constants.lsun*ss.constants.rsun^2 ;; lsun
      sedchi2 += total(((lstarsed[tofit] - ss.star[tofit].lstar.value)/(ss.fbolsedfloor*lstarsed[tofit]))^2)
   endif

   if file_test(ss.mistsedfile) then begin
      ;; MIST BC SED
      if ss.debug or keyword_set(epsname) then begin
         atmospheres = dblarr(ss.nstars,24000)
         wavelength = findgen(24000)/1000+0.1
         readcol,filepath('extinction_law.ascii',root_dir=getenv('EXOFAST_PATH'),subdir='sed'),klam,kkap,/silent
         kapv = interpol(kkap,klam,0.55)
         kapp1 = interpol(kkap,klam,wavelength)        
         for i=0L, ss.nstars-1 do begin
            exofast_interp_model3d, teffsed[i], ss.star[i].logg.value, $
                                    fehsed[i], junk, lamflam1temp, $
                                    alpha=ss.star[i].alpha.value,/next
            lamflam1=lamflam1temp*rstarsed[i]^2*ss.constants.rsun^2/ss.star[i].distance.value^2/ss.constants.pc^2
            taul1 = kapp1/kapv/1.086*ss.star[i].av.value
            extinct1 = exp(-taul1)
            atmospheres[i,*] = lamflam1*extinct1
            atmo_file = file_dirname(epsname) + path_sep() + 'modelfiles' + path_sep() + file_basename(epsname,'.sed.eps') + '.atmosphere.' + string(i,format='(i03)') + '.txt'
            exofast_forprint, wavelength, atmospheres[i,*],textout=atmo_file,/nocomment
         endfor
      endif
      sedchi2 += mistmultised(teffsed, ss.star.logg.value,fehsed, $
                              ss.star.av.value, $
                              ss.star.distance.value, lstarsed, $
                              ss.star[0].errscale.value, $
                              ss.mistsedfile, debug=ss.debug, psname=epsname,$
                              atmospheres=atmospheres, wavelength=wavelength,$
                              range=ss.sedrange)
   endif else if file_test(ss.sedfile) then begin
      sedchi2 += exofast_multised(teffsed, ss.star.logg.value,fehsed, $
                                  ss.star.av.value, $
                                  ss.star.distance.value, lstarsed, $
                                  ss.star[0].errscale.value, $
                                  ss.sedfile, rstar=ss.star.rstarsed.value,$
                                  debug=ss.debug, psname=epsname,$
                                  range=ss.sedrange,specphotpath=ss.specphotpath, $
                                  sperrscale=ss.specphot.sperrscale.value,$
                                  spzeropoint=ss.specphot.spzeropoint.value)
   endif else begin
      ;; Keivan Stassun's SED
      junk = exofast_sed(ss.star.fluxfile, teffsed, $
                         rstarsed,$
                         ss.star.av.value, ss.star.distance.value, $
                         logg=ss.star.logg.value,met=fehsed,$
                         alpha=ss.star.alpha.value,verbose=ss.verbose, $
                         f0=f, fp0=fp, ep0=ep, psname=epsname, $
                         pc=ss.constants.pc, rsun=ss.constants.rsun, $
                         logname=logname, debug=ss.debug, oned=ss.oned)
      if ~finite(junk) then begin
         if ss.debug or ss.verbose then printandlog, 'sed is bad', ss.logname
         return, !values.d_infinity
      endif
      sedchi2 += exofast_like(f-fp,0d0,ss.star.errscale.value*ep,/chi2)
   endelse
   
   ;; do some error checking
   if ~finite(sedchi2) then begin
      if ss.debug or ss.verbose then printandlog, 'sed is bad', ss.logname
      return, !values.d_infinity
   endif
   chi2 += sedchi2
   if ss.verbose then $
      printandlog, 'SED penalty = ' + strtrim(sedchi2,2), ss.logname

endif

;; Apply Chen & Kipping Mass-Radius relation 
;; http://adsabs.harvard.edu/abs/2017ApJ...834...17C
for j=0, ss.nplanets-1 do begin
   if ss.planet[j].chen then begin
      
      ;; negative radii are allowed to assess the significance of the
      ;; transit depth. That breaks these relations, so exclude them here
      if ss.planet[j].rpearth.value le 0d0 then begin
         if ss.debug or ss.verbose then printandlog, 'rpearth is bad', ss.logname
         return, !values.d_infinity
      endif
      
      rp = massradius_chen(ss.planet[j].mpearth.value > 1d-10,rperr=rperr)
      
      ;; add a chi2 penalty for deviation from the mass-radius relation
      ;; if the radius is well-constrained (by transit depth), it
      ;; becomes an implicit constraint on mass. If the mass is well
      ;; constrained (by RV), it is an explicit constraint on
      ;; radius
      chi2 += ((rp - ss.planet[j].rpearth.value)/rperr)^2
      
      if ss.verbose then printandlog, 'chen penalty = ' + strtrim(((rp - ss.planet[j].rpearth.value)/rperr)^2,2),ss.logname
   endif
endfor

;; RV model (non-interacting planets)
for j=0, ss.ntel-1 do begin

   rv = *(ss.telescope[j].rvptrs)

   if (where(rv.err^2 + ss.telescope[j].jittervar.value le 0d0))[0] ne -1 then begin
      if ss.debug or ss.verbose then printandlog, ss.telescope[j].label + ' variance is bad', ss.logname
      return, !values.d_infinity
   endif

   modelrv = dblarr(n_elements(rv.rv))
   for i=0, ss.nplanets-1 do begin

      if ss.planet[i].fitrv then begin      
         ;; rvbjd = rv.bjd ;; usually sufficient (See Eastman et al., 2013)



         q = ss.star[ss.planet[i].starndx].mstar.value/ss.planet[i].mpsun.value
         if rv.planet eq i then begin
            ;; time in target barycentric frame (expensive)
;; this needs to be debugged
            rvbjd = bjd2target(rv.bjd, inclination=ss.planet[i].i.value, $
                               a=ss.planet[i].a.value, tp=ss.planet[i].tp.value, $
                               period=ss.planet[i].period.value, e=ss.planet[i].e.value,$
                               omega=ss.planet[i].omega.value+!dpi,$
                               c=ss.constants.c/ss.constants.au*ss.constants.day,q=q)
            
            ;; calculate the RV model
            modelrv += exofast_rv(rvbjd,ss.planet[i].tp.value,ss.planet[i].period.value,$
                                  0d0,ss.planet[i].K.value*q,$
                                  ss.planet[i].e.value,ss.planet[i].omega.value+!dpi,$
                                  slope=0d0,exptime=ss.telescope[j].exptime, $
                                  ninterp=ss.telescope[j].ninterp)
         endif else begin
            ;; time in target barycentric frame (expensive)
            rvbjd = bjd2target(rv.bjd, inclination=ss.planet[i].i.value, $
                               a=ss.planet[i].a.value, tp=ss.planet[i].tp.value, $
                               period=ss.planet[i].period.value, e=ss.planet[i].e.value,$
                               omega=ss.planet[i].omega.value,/primary,$
                               c=ss.constants.c/ss.constants.au*ss.constants.day,q=q)

            ;; calculate the RV model
            if ss.planet[i].rossiter then begin
               coeffs = quadld(ss.star[ss.planet[i].starndx].logg.value,$
                          ss.star[ss.planet[i].starndx].teff.value,$
                          ss.star[ss.planet[i].starndx].feh.value,'V')
               u1claret = coeffs[0]
               u2claret = coeffs[1]
               ;; calculate the Vmac (Vzeta)
                   ; Constants
               t0 = 5777.0
               g0 = 4.44

               ; Initialize vmac
               vmac = 0.0
               teff = ss.star[ss.planet[i].starndx].teff.value
               logg = ss.star[ss.planet[i].starndx].logg.value

               ; Calculate vmac based on the given conditions
               ; Doyle et al. (2014), borrowed from iSpec
               IF logg GE 3.5 THEN BEGIN
                  IF teff GE 5000 THEN BEGIN
                        ; main sequence and subgiants (RGB)
                        vmac = 3.21 + 2.33e-3 * (teff - t0) + 2e-6 * (teff - t0)^2 - 2 * (logg - g0)
                  ENDIF ELSE BEGIN
                        ; main sequence
                        vmac = 3.21 + 2.33e-3 * (teff - t0) + 2e-6 * (teff - t0)^2 - 2 * (logg - g0)
                  ENDELSE
               ENDIF ELSE BEGIN
                  ; Out of the calibrated limits
                  vmac = 0.0
               ENDELSE
            endif else u1claret = 0d0


            if ~finite(u1claret) then begin
               if ss.verbose then begin
                  printandlog, 'V linear limb darkening coefficient (for RM effect) not defined for this star: ' +$
                               'Teff (' + strtrim(ss.star[ss.planet[i].starndx].teff.value,2) + ', ' + $
                               'logg (' + strtrim(ss.star[ss.planet[i].starndx].logg.value,2) + ', and ' + $
                               '[Fe/H] (' + strtrim(ss.star[ss.planet[i].starndx].feh.value,2) + '; rejecting step',ss.logname
               endif
               return, !values.d_infinity
            endif
            band = ss.band[ss.telescope[j].bandndx]
            u1 = band.u1.value
            u2 = band.u2.value
            if ss.planet[i].svsinicoslambda.value eq 0d0 then begin
               this_lambda = 0d0
            endif else begin
               this_lambda = atan(ss.planet[i].svsinisinlambda.value, ss.planet[i].svsinicoslambda.value)
            endelse

            this_vsini = sqrt(ss.planet[i].svsinicoslambda.value^2 + ss.planet[i].svsinicoslambda.value^2)
            modelrv += exofast_rv(rvbjd,ss.planet[i].tp.value,ss.planet[i].period.value,$
                                  0d0,ss.planet[i].K.value,$
                                  ss.planet[i].e.value,ss.planet[i].omega.value,$
                                  slope=0d0, $
                                  rossiter=ss.planet[i].rossiter, i=ss.planet[i].i.value,a=ss.planet[i].ar.value,$
                                  p=abs(ss.planet[i].p.value),vsini=this_vsini,$
                                  lambda=this_lambda,vbeta=ss.star[ss.planet[i].starndx].vbeta.value,$
                                  vgamma=ss.star[ss.planet[i].starndx].vgamma.value, vzeta=ss.star[ss.planet[i].starndx].vzeta.value,$
                                  u1=u1,u2=u2,deltarv=deltarv, exptime=ss.telescope[j].exptime, $
                                  ninterp=ss.telescope[j].ninterp)

            u1err = 0.05d0
            u2err = 0.05d0
            if ss.planet[i].rossiter then begin
               chi2 += ((band.u1.value-u1claret)/u1err)^2
               chi2 += ((band.u2.value-u2claret)/u2err)^2
               chi2 += ((ss.star[ss.planet[i].starndx].vzeta.value-vmac*1000)/1)^2
               for k=0, n_elements(rv.rv)-1 do begin
                  for i=0L, n_elements(*ss.priors)-1 do begin
                     prior = (*ss.priors)[i]
                     ;; get the model value
                     if prior.map[4] ne -1 then begin
                        label = (*ss.(prior.map[0])[prior.map[1]].(prior.map[2])[prior.map[3]]).(prior.map[4])[prior.map[5]].label
                     endif else if prior.map[2] ne -1 then begin
                        label = ss.(prior.map[0])[prior.map[1]].(prior.map[2])[prior.map[3]].label
                     endif else if prior.map[0] ne -1 then begin
                        label = ss.(prior.map[0])[prior.map[1]].label
                     endif
                     ;; apply the bounds
                     if label eq 'vsini' then break
                  endfor
               endfor
               chi2 += ((this_vsini - prior.value[0])/prior.gaussian_width)^2
            endif
         endelse

      endif

   endfor

   if keyword_set(psname) then begin
      ;; without gamma, gammadot, gammadotdot, or detrending
      base = file_dirname(psname) + path_sep() + 'modelfiles' + path_sep() + file_basename(psname,'.model')
      exofast_forprint, rv.bjd, modelrv, format='(f0.8,x,f0.6,x,f0.6)', textout=base + '.detrendedmodel.telescope_' + string(j,format='(i02)') + '.txt', /nocomment,/silent
   endif

   ;; add instrumental offset, slope, and quadratic term
   modelrv += ss.telescope[j].gamma.value 
   if (*ss.telescope[j].rvptrs).planet eq -1 then $
      modelrv += ss.star[0].slope.value*(rv.bjd-ss.rvepoch) + ss.star[0].quad.value*(rv.bjd-ss.rvepoch)^2

   ;; detrending
   modelrv += total((*ss.telescope[j].rvptrs).detrendadd*(replicate(1d0,n_elements((*ss.telescope[j].rvptrs).bjd))##(*ss.telescope[j].rvptrs).detrendaddpars.value),1)
   modelrv *= (1d0+total((*ss.telescope[j].rvptrs).detrendmult*(replicate(1d0,n_elements((*ss.telescope[j].rvptrs).bjd))##(*ss.telescope[j].rvptrs).detrendmultpars.value),1))

   (*ss.telescope[j].rvptrs).residuals = rv.rv - modelrv

   if keyword_set(psname) then begin
      base = file_dirname(psname) + path_sep() + 'modelfiles' + path_sep() + file_basename(psname,'.model')
      exofast_forprint, rv.bjd, rv.rv - modelrv, rv.err, format='(f0.8,x,f0.6,x,f0.6)', textout=base + '.residuals.telescope_' + string(j,format='(i02)') + '.txt', /nocomment,/silent
      exofast_forprint, rv.bjd, modelrv, format='(f0.8,x,f0.6)', textout=base + '.model.telescope_' + string(j,format='(i02)') + '.txt', /nocomment,/silent
      
      trend = ss.telescope[j].gamma.value + ss.star[0].slope.value*(rv.bjd-ss.rvepoch) + ss.star[0].quad.value*(rv.bjd-ss.rvepoch)^2
      exofast_forprint, rv.bjd, trend, format='(f0.8,x,f0.6)', textout=base + '.trend.telescope_' + string(j,format='(i02)') + '.txt', /nocomment,/silent

   endif

   rvchi2 = exofast_like((*ss.telescope[j].rvptrs).residuals,ss.telescope[j].jittervar.value,rv.err,/chi2)
   if ~finite(rvchi2) then stop
   chi2 += rvchi2
   if ss.verbose then printandlog, ss.telescope[j].label + ' RV penalty = ' + strtrim(rvchi2,2),ss.logname
endfor

;; if at least one RV planet is fit, plot it
if (where(ss.planet.fitrv))[0] ne -1 then begin
   if keyword_set(psname) then begin
      plotrv, ss, psname=psname + '.rv.ps',range=ss.rvrange
   endif else if ss.debug then begin
      plotrv, ss,range=ss.rvrange
   endif
endif

;; Doppler Tomography Model
for i=0, ss.ndt-1 do begin
   if keyword_set(psname) then epsname = psname + '.dt_' + string(i,format='(i02)') + '.eps'

   planetndx = (*(ss.doptom[i].dtptrs)).planetndx
   starndx = ss.planet[planetndx].starndx
   dtchi2 = dopptom_chi2(*(ss.doptom[i].dtptrs),$
                         ss.planet[planetndx].tc.value, $
                         ss.planet[planetndx].period.value, $
                         ss.planet[planetndx].e.value,$
                         ss.planet[planetndx].omega.value, $
                         ss.planet[planetndx].cosi.value, $
                         ss.planet[planetndx].p.value,$
                         ss.planet[planetndx].ar.value,$
                         ss.planet[planetndx].lambda.value, $
                         ss.star[starndx].logg.value, $
                         ss.star[starndx].teff.value, $
                         ss.star[starndx].feh.value,$
                         ss.star[starndx].vsini.value/1d3,$
                         ss.star[starndx].vline.value/1d3,$
                         ss.doptom[i].dtscale.value, debug=ss.debug,$
                         /like,psname=epsname,c=ss.constants.c/1e5,$
                         verbose=ss.verbose, logname=ss.logname)

   if ~finite(dtchi2) then begin
      if ss.verbose or ss.debug then $
         printandlog, (*ss.doptom[i].dtptrs).label + ': DT chi2 is bad',$
                      ss.logname
      return, !values.d_infinity
   endif
   chi2 += dtchi2
   if ss.verbose then printandlog,(*ss.doptom[i].dtptrs).label+' DT penalty = '+$
                                  strtrim(dtchi2,2),ss.logname
endfor

;; compute the stellar flux for each star in each transit band 
;; if dilution is being fit
if (*ss.dilutebandndx)[0] ne -1 then begin
   starndx = ss.dilutestarndx
   bandndx = *ss.dilutebandndx
   starflux = deblend(ss.star[starndx].teff.value, ss.star[starndx].logg.value,$
                      ss.star[starndx].feh.value, ss.star[starndx].av.value, $
                      ss.star[starndx].distance.value, $
                      ss.star[starndx].lstar.value, ss.band[bandndx].name)
endif

;; transit timing model
for i=0, ss.nplanets-1 do begin
   ttdata = *(ss.planet[i].transittimingptrs)
   if ttdata ne !null then begin
      ttchi2 = 0d0
      transittimes = ttdata[0,*]
      transittimeserrs = ttdata[1,*]
      for j=0, n_elements(transittimes)-1 do begin
         nearest_epoch = round((transittimes[j]-ss.planet[i].tc.value)/ss.planet[i].period.value)
         tc_pred = ss.planet[i].tc.value + nearest_epoch*ss.planet[i].period.value
         ttchi2 += ((transittimes[j] - tc_pred)/transittimeserrs[j])^2
         ;print, FORMAT='(A, F16.8,A, F16.8,A, F16.8)', 'transittime: ',transittimes[j],' tc_pred: ',tc_pred,' err: ',transittimeserrs[j]
      endfor


      chi2 += ttchi2
      if ss.verbose then printandlog, 'Transit Timing penalty = ' + strtrim(ttchi2,2),ss.logname
   endif
endfor




;; Transit model
for j=0L, ss.ntran-1 do begin

   transit = *(ss.transit[j].transitptrs)
   
   if ss.fitdilute[j] then begin

      matchstar = where(ss.seddeblend[j,*])
      ;; dilute transit according to other stars' SEDs
      if ss.nstars gt 1 and (matchstar[0] ne -1) then begin
         matchband = (where(*ss.dilutebandndx eq ss.transit[j].bandndx))[0]
         planetndx = ss.transit[j].pndx
         starndx = ss.planet[planetndx].starndx
         dilute = 1d0-starflux[matchband,starndx]/total(starflux[matchband,matchstar])      
         dilutechi2 = ((ss.transit[j].dilute.value - dilute)/(dilute*0.05d0))^2   
         chi2 += dilutechi2

         if ss.verbose then begin
            name = ss.band[ss.transit[j].bandndx].name
            printandlog, "SED " + name + " model dilution = " + strtrim(dilute,2) + ', dilution parameter: ' + strtrim(ss.transit[j].dilute.value,2),ss.logname
            printandlog, "SED " + name + " deblending penalty: " + strtrim(dilutechi2,2), ss.logname
         endif
      endif else begin
         ;; otherwise, let it float (constrained by priors/other bands)
      endelse
   endif

   if (where(transit.err^2 + ss.transit[j].variance.value le 0d0))[0] ne -1 then begin
      if ss.verbose then printandlog, transit.label + ' variance + err^2 < 0. If this is the starting model, check the supplied errors are accurate and the starting value for variance_' + strtrim(j,2) + ' is sensible; rejecting step', ss.logname
      return, !values.d_infinity
   endif

   band = ss.band[ss.transit[j].bandndx]
   planetndx = ss.transit[j].pndx
   starndx = ss.planet[planetndx].starndx

   ;; quadratic limb darkening
   if ss.transit[j].claret then begin
      ldcoeffs = quadld(ss.star[starndx].logg.value, $
                        ss.star[starndx].teff.value, $
                        ss.star[starndx].feh.value, band.name, $
                        verbose=ss.verbose, logname=ss.logname)
      u1claret = ldcoeffs[0]
      u2claret = ldcoeffs[1]
      if ~finite(u1claret) or ~finite(u2claret) then begin
         if ss.verbose then begin
            printandlog, band.label + ' limb darkening coefficients are not defined at this ' +$
                         'Teff (' + strtrim(ss.star[starndx].teff.value,2) + ', ' + $
                         'logg (' + strtrim(ss.star[starndx].logg.value,2) + ', and ' + $
                         '[Fe/H] (' + strtrim(ss.star[starndx].feh.value,2) + '; rejecting step',ss.logname
         endif
         return, !values.d_infinity
      endif
      u1err = 0.05d0
      u2err = 0.05d0
      chi2 += ((band.u1.value-u1claret)/u1err)^2
      chi2 += ((band.u2.value-u2claret)/u2err)^2
      if ss.verbose then printandlog, band.label + ' u1 penalty = ' + strtrim(((band.u1.value-u1claret)/u1err)^2,2),ss.logname
      if ss.verbose then printandlog, band.label + ' u2 penalty = ' + strtrim(((band.u2.value-u2claret)/u2err)^2,2),ss.logname
   endif

   ;; Kepler Long candence data; create several model points and average   
   ninterp = ss.transit[j].ninterp
   npoints = n_elements(transit.bjd)

   if ninterp gt 1 then begin
      transitbjd = transit.bjd#(dblarr(ninterp)+1d0) + $
                   ((dindgen(ninterp)/ninterp-(ninterp-1d0)/(2d0*ninterp))/$
                    1440d0*ss.transit[j].exptime)##(dblarr(npoints)+1d0)
      modelflux = dblarr(npoints,ninterp) + 1d0
   endif else begin
      transitbjd = transit.bjd
      modelflux = dblarr(npoints) + 1d0
   endelse

   for i=0, ss.nplanets-1 do begin
      if ss.planet[i].fittran then begin

         tmpmodelflux = (exofast_tran(transitbjd, $
                                    ss.planet[i].i.value + ss.transit[j].tiv.value, $
                                    ss.planet[i].ar.value, $
                                    ss.planet[i].tp.value + ss.transit[j].ttv.value, $
                                    ss.planet[i].period.value, $
                                    ss.planet[i].e.value,$
                                    ss.planet[i].omega.value,$
                                    ss.planet[i].p.value + ss.transit[j].tdeltav.value,$
                                    band.u1.value, $
                                    band.u2.value, $
                                    1d0, $
                                    q=ss.star[ss.planet[i].starndx].mstar.value/ss.planet[i].mpsun.value, $
                                    thermal=band.thermal.value, $
                                    reflect=band.reflect.value, $
                                    phaseshift=band.phaseshift.value, $
                                    beam=ss.planet[i].beam.value,$
                                    dilute=ss.transit[j].dilute.value,$
                                    tc=ss.planet[i].tc.value,$
                                    rstar=ss.star[ss.planet[i].starndx].rstar.value/AU,$
                                    ;x1=x1,y1=y1,z1=z1,$
                                    au=au,$
                                    c=ss.constants.c/ss.constants.au*ss.constants.day) - 1d0)

         modelflux += tmpmodelflux

      endif
   endfor
   
   if ss.transit[j].rejectflatmodel then begin
      minmodel = min(modelflux,max=maxmodel)
      if minmodel eq maxmodel then begin
         if ss.verbose then printandlog, ss.transit[j].label + ' transit model is a flat line, which is not allowed by the REJECTFLATMODEL input! This may artificially enhance the significance of the signal', ss.logname
         return, !values.d_infinity
      endif
   endif

   ;; ellipsoidal variations
   if band.ellipsoidal.value ne 0d0 then begin
      minperiod = min(ss.planet.period.value,ndx)
      modelflux = modelflux * (1d0 - band.ellipsoidal.value/1d6*cos(2d0*!dpi*(transitbjd-ss.planet[ndx].tc.value)/(ss.planet[ndx].period.value/2d0)))
   endif

   ;; now integrate the model points (before detrending)
   ;; Riemann integration beats trapezoidal and simpsons wins when
   ;; sampling like above
   if ninterp gt 1 then modelflux = total(modelflux,2)/ninterp

   ;; Trapezoidal integration not as good
   ;;if ninterp gt 1 then modelflux = (total(modelflux,2) - modelflux[*,0]/2d0 - modelflux[*,-1]/2d0)/(ninterp-1d0)

   ;; Simpson integration (about 2x worse than trap because it
   ;; requires sampling at the midpoint, effectively halving our resolution)
   ;if ninterp gt 1 then modelflux = (4d0*total(modelflux,2) - 3d0*modelflux[*,0] - 3d0*modelflux[*,-1])/(4d0*ninterp - 6d0)

   ;; detrending
   modelflux += total(transit.detrendadd*(replicate(1d0,n_elements(transit.bjd))##transit.detrendaddpars.value),1) 
   modelflux *= (ss.transit[j].f0.value + $
                 total(transit.detrendmult*(replicate(1d0,n_elements(transit.bjd))##transit.detrendmultpars.value),1))

   ;; exponential ramp (e.g., Spitzer & JWST)
   if ss.transit[j].fitramp then begin
      ramp_profile = (1d0+ss.transit[j].rampamp.value*exp((transit.bjd[0]-transit.bjd)/ss.transit[j].rampexp.value)) 

      ;; A*exp(-t/tau) ~ A*(1-t/tau + t/tau^2/2 + ...)
      ;; The leading term of the ramp looks a lot like F0. 
      ;; Subtract A to reduce covariance with F0
      ramp_profile -= ss.transit[j].rampamp.value 

      ;; The second order term of the ramp looks a lot like time decorrelation. Subtract?
;      ramp_profile -= ss.transit[j].rampamp.value*(transit.bjd[0]-transit.bjd)/ss.transit[j].rampexp.value) ;; this term has a near-perfect correlation with time

      ;; The third order term of the ramp looks a lot like time^2 decorrelation. Subtract?
;      ramp_profile -= ss.transit[j].rampamp.value*(transit.bjd[0]-transit.bjd)/(ss.transit[j].rampexp.value)^2*2d0) ;; this term has a near-perfect correlation with time^2

      bad = where(~finite(ramp_profile),nbad)
      if nbad gt 0 then print, ss.transit[j].rampamp.value, ss.transit[j].rampexp.value
      modelflux *= ramp_profile
   endif
   

   ;; fit Andrew Vanderburg's keplerspline to the residuals to detrend the lightcurve
   if ss.transit[j].fitspline then begin
      if transit.breakpts[0] eq -1 then $         
         norm = keplerspline(transit.bjd, transit.flux-modelflux+1d0, ndays=ss.transit[j].splinespace) $
      else norm = keplerspline(transit.bjd, transit.flux-modelflux+1d0, breakp=transit.breakpts, ndays=ss.transit[j].splinespace)
      modelflux *= norm
   endif else norm = 1d0

phase = (transitbjd - ss.planet[0].tc.value) mod ss.planet[0].period.value
toohigh = where(phase gt ss.planet[0].period.value/2d0)
if toohigh[0] ne -1 then phase[toohigh] -= ss.planet[0].period.value
toolow = where(phase lt -ss.planet[0].period.value/2d0)
if toolow[0] ne -1 then phase[toohigh] += ss.planet[0].period.value

;set_plot, 'ps'
;device, filename='toi2165.ps'
;loadct, 39, /silent
;red = 254
;sorted = sort(phase)
;plot, phase, transit.flux, psym=1, /ynoz, xtitle='phased time', ytitle='Normalized flux'
;oplot, phase[sorted], modelflux[sorted],color=red
;device, /close
;spawn, 'gv toi2165.ps &'
;stop

   ;; chi^2
   if ss.transit[j].sigma_r.fit then begin
      transitchi2 = -2d0*exofast_wavelike(transit.flux - modelflux,ss.transit[j].sigma_r.value,mean(transit.err),/zeropad)
   endif else begin
      transitchi2 = exofast_like(transit.flux - modelflux,ss.transit[j].variance.value,transit.err,/chi2)
   endelse

   (*ss.transit[j].transitptrs).residuals = transit.flux - modelflux
;   (*ss.transit[j].transitptrs).model = modelflux

   if keyword_set(psname) then begin
      base = file_dirname(psname) + path_sep() + 'modelfiles' + path_sep() + file_basename(psname,'.model')
      exofast_forprint, transit.bjd, transit.flux - modelflux, transit.err, format='(f0.8,x,f0.6,x,f0.6)', textout=base + '.residuals.transit_' + string(j,format='(i03)') + '.txt', /nocomment,/silent
      exofast_forprint, transit.bjd, modelflux, format='(f0.8,x,f0.6)', textout=base + '.model.transit_' + string(j,format='(i03)')+ '.txt', /nocomment,/silent
      
      if ss.transit[j].fitspline then $
         exofast_forprint, transit.bjd, norm, format='(f0.8,x,f0.6)',$
                           textout=base+'.spline.transit_' + string(j,format='(i03)') + '.txt', /nocomment,/silent
      
   endif

   if ~finite(transitchi2) then begin
      printandlog, 'the transit model likelihood is not finite. this should not happen. please inspect input files'
      stop
   endif

   chi2 += transitchi2
   if ss.verbose then printandlog, ss.transit[j].label + ' transit penalty: ' + strtrim(transitchi2,2) + ' ' + strtrim(ss.transit[j].variance.value,2),ss.logname

endfor

;; plot the transit model and data 
;; if a transit is fit for at least one planet
if ((where(ss.planet.fittran))[0] ne -1) then begin
   if keyword_set(psname) then begin
      plottran, ss, psname=psname + '.transit.ps', range=ss.transitrange
   endif else if ss.debug then begin
      plottran, ss, range=ss.transitrange
   endif
endif

;; if TTVs are allowed, add a chi2 penalty to the period and t0 from
;; the fit to a linear ephemeris
;; this imposes the constraint of the linear ephemeris while allowing TTVs
for i=0L, ss.nplanets-1L do begin

   if ~ss.planet[i].fittran then continue

   ;; ensure the tdeltavs average to zero
   good = where(ss.tdeltavs[*,i],ngood)
   if ngood ge 2 then begin
      sigma = stdev(ss.transit[good].tdeltav.value)
      if sigma gt 0d0 then begin
         chi2 += (mean(ss.transit[good].tdeltav.value)/sigma)^2
         if ss.verbose then printandlog, 'TDELTAV penalty ' + strtrim((mean(ss.transit[good].tdeltav.value)/sigma)^2,2)
      endif
   endif else if ngood ne 0 then begin
      printandlog, 'ERROR: TDELTAVs are requested for planet ' + strtrim(i,2) + ', but must have at least 2 transits', ss.logname
      stop
   endif
 
   ;; ensure the tivs average to zero
   good = where(ss.tivs[*,i],ngood)
   if ngood ge 2 then begin
      sigma = stdev(ss.transit[good].tiv.value)
      if sigma gt 0d0 then begin
         chi2 += (mean(ss.transit[good].tiv.value)/sigma)^2
         if ss.verbose then printandlog, 'TIV penalty ' + strtrim((mean(ss.transit[good].tiv.value)/sigma)^2,2)
      endif
   endif else if ngood ne 0 then begin
      printandlog, 'ERROR: TIVs are requested for planet ' + strtrim(i,2) + ', but must have at least 2 transits', ss.logname
      stop
   endif

   ;; ensure the TTVs average to the ephermeris
   good = where(ss.ttvs[*,i],ngood)
   if ngood eq 0 then continue
   if ngood le 2 then begin
      printandlog, 'ERROR: TTVs are requested for planet ' + strtrim(i,2) + ', but must have at least 3 transits', ss.logname
      stop
   endif
   
   time = ss.epochs[good,i]*ss.planet[i].period.value+ss.transit[good].ttv.value
   ;time = ss.planet[i].tt.value + ss.epochs[good,i]*ss.planet[i].period.value+ss.transit[good].ttv.value
   
;      fit = bytarr(ss.ntran)
;      epochs = dblarr(ss.ntran)
;      time = dblarr(ss.ntran)
;      for j=0L, ss.ntran-1L do begin
;         if ss.transit[j].ttv.fit then begin
;            minbjd = min((*ss.transit[j].transitptrs).bjd,max=maxbjd)
;            epochs[j] = round(((maxbjd+minbjd)/2d0 - ss.planet[i].tc.value)/ss.planet[i].period.value)
;            time[j] = ss.planet[i].tc.value + epochs[j]*ss.planet[i].period.value
;            if time[j] gt minbjd and time[j] lt maxbjd then fit[j] = 1B
;         endif
;      endfor
;
;stop
   
;      good = where(fit,ngood) ;; why wouldn't that be finite??
;      if ngood eq 0 then continue
;      if ngood le 2 then begin
;         if ss.verbose then printandlog, 'ERROR: TTVs are requested for planet ' + strtrim(i,2) + ', but must have at least 3 transits', ss.logname
;         continue
;      endif
   
   coeffs = poly_fit(ss.epochs[good,i],time,1, sigma=sigma, yfit=yfit)
   sigma = sigma > 1d-18
   chi2 += ((coeffs[0])/sigma[0])^2
   chi2 += ((coeffs[1]-ss.planet[i].period.value)/sigma[1])^2
   if ss.verbose then begin
      printandlog, 'Tc penalty ' + strtrim(((coeffs[0])/sigma[0])^2,2),ss.logname
      printandlog, 'Period penalty ' + strtrim(((coeffs[1]-ss.planet[i].period.value)/sigma[1])^2,2),ss.logname
   endif

   if ss.debug or keyword_set(psname) then begin
      if keyword_set(psname) then begin
         ;; astrobetter.com tip on making pretty IDL plots
         mydevice=!d.name
         set_plot, 'PS'
         aspect_ratio=1.5
         xsize=10.5
         ysize=xsize/aspect_ratio
         !p.font=0
         device, filename=psname + '.ttv.' + strtrim(i,2) + '.eps', /color, bits=24,/encapsulated
         device, xsize=xsize, ysize=ysize
         LOADCT, 39,/silent
         colors = [0,254,159,95,223,31,207,111,191,47]
         charsizelegend = 0.09
         xlegend = 0.1
         ylegend = 0.90
         charsize = 0.5
      endif else begin
         device,window_state=win_state
         if win_state[10+i] eq 1 then wset, 10+i $
         else window, 10+i, retain=2
         colors= ['ffffff'x,'0000ff'x,'00ff00'x,'ff0000'x,'0080ff'x,$
                  '800080'x,'00ffff'x,'ffff00'x,'80d000'x,'660000'x]
         charsizelegend = 0.03
         xlegend = 0.90
         ylegend = 0.95
         charsize = 1
      endelse
      ncolors = n_elements(colors)
      syms = [0,3,8,5,0,3,8,5]
      fill = [1,1,1,1,0,0,0,0]
      nsyms = n_elements(syms)
      
      telescopes = strarr(ss.ntran)
      for j=0L, ss.ntran-1L do telescopes[j] = (strsplit(ss.transit[j].label,' UT ',/regex,/extract))[0]
      sorted = sort(telescopes)
      tnames = telescopes[sorted[uniq(telescopes[sorted])]]
      
      xmin = min((ss.epochs)[good,i],max=xmax)
      ymin = min((time-yfit)*1440d0,max=ymax)
      plot, [0],[0],psym=3, xtitle='!3Epoch', ytitle='!3O-C (min)',xrange=[xmin,xmax],yrange=[ymin,ymax]
      for j=0, n_elements(tnames)-1 do begin
         observed = where(telescopes eq tnames[j])
         if observed[0] ne -1 then begin
            plotsym, syms[j mod nsyms], color=colors[j mod ncolors],fill=fill[j mod nsyms]
            oplot, (ss.epochs[good,i])[observed],(time[observed]-yfit[observed])*1440d0,psym=8
            xsize = (!x.crange[1] - !x.crange[0])
            ysize = (!y.crange[1] - !y.crange[0])
            
            ;; only need a legend if we have more than one telescope
            if n_elements(tnames) gt 1 then begin
               xyouts, !x.crange[0] + xlegend*xsize,!y.crange[0]+(ylegend - j*charsizelegend)*ysize, $
                       tnames[j],color=colors[j mod ncolors],charsize=charsize
               oplot, [!x.crange[0]+xlegend*xsize-xsize/20],$
                      [!y.crange[0]+(ylegend - (j-0.25)*charsizelegend)*ysize],psym=8
            endif
         endif
      endfor
      oplot, [-9d9,9d9],[0d0,0d0],linestyle=2
      
      if keyword_set(psname) then begin
         !p.font=-1
         !p.multi=0
         device, /close
         device, encapsulated=0
         set_plot, mydevice
      endif
      
   endif
endfor

;; astrometric model
nastromplots = 4
for i=0L, ss.nastrom-1 do begin

   astrom = *(ss.astrom[i].astromptrs)
   starndx = ss.astrom[i].starndx

   ;; get the motion of the star due to all planets relative to its barycenter 
   ;; in units of rstar
   junk = exofast_getb2(astrom.bjdtdb,inc=ss.planet.i.value,a=ss.planet.ar.value,$
                        tperiastron=ss.planet.tp.value,$
                        period=ss.planet.period.value,$
                        e=ss.planet.e.value,omega=ss.planet.omega.value,$
                        lonascnode=ss.planet.bigomega.value,$
                        q=ss.star[starndx].mstar.value/ss.planet.mpsun.value,$
                        x1=x1,y1=y1,z1=z1, x0=x0,y0=y0,z0=z0)

   ;; Photocenter in AU about the system barycenter
   if ss.band[ss.astrom[i].bandndx].dilute.value eq 0d0 then begin
      ;; If not diluted, it simplifies to the stellar position
      starpos = transpose([[x1],[y1],[z1]])*ss.star[starndx].rstar.value*ss.constants.rsun/ss.constants.au 
   endif else begin
      ;; Otherwise, must account for blending
      ;; See https://arxiv.org/pdf/1807.09880.pdf, Appendix B
      phottobary = ss.band[ss.astrom[i].bandndx].phottobary.value

      ;; ****check sign returned by exofast_getb2!!!****
      starpos = -[x0[0,*],y0[0,*],z0[0,*]]*ss.star[starndx].rstar.value*ss.constants.rsun/ss.constants.au/phottobary

      ;; this breaks for multiple, bright planets (triple stars?)!!!
      if ss.verbose and ss.nplanets gt 1 then printandlog, 'WARNING: multiple bright companions not supported!', ss.logname
   endelse

   if ~keyword_set(astrom.userhopa) then begin
      ;; get the stellar coordinates (angles) relative to ICRS
      radec = exofast_astrom(astrom.bjdtdb, ss.star[starndx].ra.value+ss.astrom[i].raoffset.value,$
                             ss.star[starndx].dec.value+ss.astrom[i].decoffset.value, $
                             ss.star[starndx].pmra.value, ss.star[starndx].pmdec.value, $
                             px=ss.star[starndx].parallax.value, $
                             rv=ss.star[starndx].rvabs.value, $
                             epoch=astrom.epoch,obspos=astrom.obspos, $
                             au=ss.constants.au/ss.constants.meter, starpos=starpos)
      astromchi2 = exofast_like(radec-astrom.radec,0d0,ss.astrom[i].astromscale.value*astrom.err,/chi2)
   endif else begin

      ;; scale factor to convert units of rstar to mas
      ascale = ss.star[starndx].rstar.value*ss.constants.rsun/ss.constants.pc/ss.star[starndx].distance.value*3600d3*180/!dpi


      rhopa = transpose([[sqrt(x1^2 + y1^2)*ascale],[atan(y1,x1)]])
      astromchi2 = exofast_like(rhopa-astrom.rhopa,0d0,ss.astrom[i].astromscale.value*astrom.rhopaerr,/chi2)
   endelse

   if ss.verbose then printandlog, ss.astrom[i].label + ' astrometry penalty: ' + strtrim(astromchi2,2),ss.logname
   if ~finite(astromchi2) then begin
      printandlog, ss.astrom[i].label + ': NaN chi^2 from astrometry!', ss.logname
      return, !values.d_infinity
   endif

   chi2 += astromchi2

   if ss.debug or keyword_set(psname) then begin
      if keyword_set(psname) then begin
         ;; astrobetter.com tip on making pretty IDL plots
         mydevice=!d.name
         set_plot, 'PS'
         aspect_ratio=1.5
         xsize=10.5
         ysize=xsize/aspect_ratio
         !p.font=0
         device, filename=psname + '.astrometry.' + strtrim(i,2) + '.ps', /color, bits=24
         device, xsize=xsize, ysize=ysize
         LOADCT, 39,/silent
         colors = [0,254,159,95,223,31,207,111,191,47]
         charsizelegend = 0.09
         xlegend = 0.1
         ylegend = 0.90
         charsize = 0.5
      endif else begin
         device,window_state=win_state
         colors= ['ffffff'x,'0000ff'x,'00ff00'x,'ff0000'x,'0080ff'x,$
                  '800080'x,'00ffff'x,'ffff00'x,'80d000'x,'660000'x]
         charsizelegend = 0.03
         xlegend = 0.90
         ylegend = 0.95
         charsize = 1
      endelse
      ncolors = n_elements(colors)
      syms = [0,3,8,5,0,3,8,5]
      fill = [1,1,1,1,0,0,0,0]
      nsyms = n_elements(syms)

      ;; get the motion of the star due to all planets relative to its barycenter 
      ;; in units of rstar
      junk = exofast_getb2(astrom.prettytime,inc=ss.planet.i.value,a=ss.planet.ar.value,$
                           tperiastron=ss.planet.tp.value,$
                           period=ss.planet.period.value,$
                           e=ss.planet.e.value,omega=ss.planet.omega.value,$
                           lonascnode=ss.planet.bigomega.value,$
                           q=ss.star[starndx].mstar.value/ss.planet.mpsun.value,$
                           x1=prettyx1,y1=prettyy1,z1=prettyz1, x0=prettyx0,y0=prettyy0,z0=prettyz0)        
      
      if ~keyword_set(astrom.userhopa) then begin
         radecnocompanion = exofast_astrom(astrom.bjdtdb, ss.star[starndx].ra.value+ss.astrom[i].raoffset.value,$
                                           ss.star[starndx].dec.value+ss.astrom[i].decoffset.value, $
                                           ss.star[starndx].pmra.value, ss.star[starndx].pmdec.value, $
                                           px=ss.star[starndx].parallax.value, $
                                           rv=ss.star[starndx].rvabs.value, $
                                           epoch=astrom.epoch,obspos=astrom.obspos, $
                                           au=ss.constants.au/ss.constants.meter, starpos=0d0)
         
         ;; Photocenter in AU about the system barycenter
         if ss.band[ss.astrom[i].bandndx].dilute.value eq 0d0 then begin
            ;; If not diluted, it simplifies to the stellar position
            prettystarpos = transpose([[prettyx1],[prettyy1],[prettyz1]])*ss.star[starndx].rstar.value*ss.constants.rsun/ss.constants.au 
         endif else begin
            ;; Otherwise, must account for blending
            ;; See https://arxiv.org/pdf/1807.09880.pdf, Appendix B
            ;; ****check sign returned by exofast_getb2!!!****
            prettystarpos = -[prettyx0[0,*],prettyy0[0,*],prettyz0[0,*]]*ss.star[starndx].rstar.value*ss.constants.rsun/ss.constants.au/phottobary        
            ;; this breaks for multiple, bright planets (triple stars?)!!!
            if ss.verbose and ss.nplanets gt 1 then printandlog, 'WARNING: multiple bright companions not supported!', ss.logname
         endelse
         
         prettyradec = exofast_astrom(astrom.prettytime, ss.star[starndx].ra.value+ss.astrom[i].raoffset.value,$
                                      ss.star[starndx].dec.value+ss.astrom[i].decoffset.value, $
                                      ss.star[starndx].pmra.value, ss.star[starndx].pmdec.value, $
                                      px=ss.star[starndx].parallax.value, $
                                      rv=ss.star[starndx].rvabs.value, $
                                      epoch=astrom.epoch,obspos=astrom.prettyobspos, $
                                      au=ss.constants.au/ss.constants.meter, starpos=prettystarpos)
         
         prettyradecnocompanion = exofast_astrom(astrom.prettytime, ss.star[starndx].ra.value+ss.astrom[i].raoffset.value,$
                                                 ss.star[starndx].dec.value+ss.astrom[i].decoffset.value, $
                                                 ss.star[starndx].pmra.value, ss.star[starndx].pmdec.value, $
                                                 px=ss.star[starndx].parallax.value, $
                                                 rv=ss.star[starndx].rvabs.value, $
                                                 epoch=astrom.epoch,obspos=astrom.prettyobspos, $
                                                 au=ss.constants.au/ss.constants.meter, starpos=0d0)
         
         
         xmin = min(astrom.bjdtdb-astrom.epoch,max=xmax)
         ymin = min([[radec[0,*],astrom.radec[0,*]]-ss.star[starndx].ra.value,[radec[1,*],astrom.radec[1,*]]-ss.star[starndx].dec.value],max=ymax)
         
         if ~keyword_set(psname) then begin
            if win_state[i*nastromplots] eq 1 then wset, i*nastromplots $
            else window, i*nastromplots, retain=2
         endif
         plot, astrom.prettytime-astrom.epoch, (prettyradec[0,*]-ss.star[starndx].ra.value)*3600d6, xtitle='Time - ' + strtrim(astrom.epoch,2) + ' (days)', xrange=[xmin,xmax], yrange=[ymin,ymax]*3600d6,ytitle=exofast_textoidl('Motion (\muas)')
         oplot, astrom.prettytime-astrom.epoch, (prettyradec[1,*]-ss.star[starndx].dec.value)*3600d6,color=colors[1]
         oplot, astrom.bjdtdb-astrom.epoch, (astrom.radec[0,*]-ss.star[starndx].ra.value)*3600d6, psym=1
         oplot, astrom.bjdtdb-astrom.epoch, (astrom.radec[1,*]-ss.star[starndx].dec.value)*3600d6,psym=1,color=colors[1]
         
         if ~keyword_set(psname) then begin
            if win_state[i*nastromplots+1] eq 1 then wset, i*nastromplots+1 $
            else window, i*nastromplots+1, retain=2
         endif
         plot, (prettyradec[0,*]-ss.star[starndx].ra.value)*3600d6,(prettyradec[1,*]-ss.star[starndx].dec.value)*3600d6, xtitle=exofast_textoidl('\alpha - \alpha_0 (\muas)'), ytitle=exofast_textoidl('\delta-\delta_0 (\muas)'),/iso, xrange=[ymin,ymax]*3600d6,yrange=[ymin,ymax]*3600d6
         oplot, (astrom.radec[0,*]-ss.star[starndx].ra.value)*3600d6,(astrom.radec[1,*]-ss.star[starndx].dec.value)*3600d6, psym=1
         
         if ~keyword_set(psname) then begin
            if win_state[i*nastromplots+2] eq 1 then wset, i*nastromplots+2 $
            else window, i*nastromplots+2, retain=2
         endif
         ymin = min([radec[0,*]-radecnocompanion[0,*],astrom.radec[0,*]-radecnocompanion[0,*],radec[1,*]-radecnocompanion[1,*],astrom.radec[1,*]-radecnocompanion[1,*]],max=ymax)
         plot, (prettyradec[0,*]-prettyradecnocompanion[0,*])*3600d6, (prettyradec[1,*]-prettyradecnocompanion[1,*])*3600d6, xtitle=exofast_textoidl('\alpha - \alpha_0 (\muas)'), ytitle=exofast_textoidl('\delta-\delta_0 (\muas)'),/iso, yrange=[ymin,ymax]*3600d6,xrange=[ymax,ymin]*3600d6
         oplot, (astrom.radec[0,*]-radecnocompanion[0,*])*3600d6, (astrom.radec[1,*]-radecnocompanion[1,*])*3600d6, psym=1
         
         if ~keyword_set(psname) then begin
            if win_state[i*nastromplots+3] eq 1 then wset, i*nastromplots+3 $
            else window, i*nastromplots+3, retain=2
         endif
         plot, astrom.prettytime-astrom.epoch, (prettyradec[0,*]-prettyradecnocompanion[0,*])*3600d6, xtitle='Time - ' + strtrim(astrom.epoch,2) + ' (days)', ytitle=exofast_textoidl('Residuals (\muas)'), yrange=[ymin,ymax]*3600d6,xrange=[xmin,xmax]
         oplot, astrom.bjdtdb-astrom.epoch, (astrom.radec[0,*]-radecnocompanion[0,*])*3600d6, psym=1
         oplot, astrom.prettytime-astrom.epoch, (prettyradec[1,*]-prettyradecnocompanion[1,*])*3600d6, color=colors[1]
         oplot, astrom.bjdtdb-astrom.epoch, (astrom.radec[1,*]-radecnocompanion[1,*])*3600d6, color=colors[1], psym=1
      endif else begin
         ascale*=5
         xmin=max(prettyy1*ascale,min=xmax)
         ymin=min(prettyx1*ascale,max=ymax)
         plot, prettyy1*ascale, prettyx1*ascale, xtitle='East (mas)',ytitle='North (mas)',/iso, xrange=[xmin,xmax],yrange=[ymin,ymax]
         oplot, [0],[0], psym=2
         eastdata = astrom.rhopa[0,*]*cos(astrom.rhopa[1,*])
         northdata = astrom.rhopa[0,*]*sin(astrom.rhopa[1,*])
         oplot, eastdata, northdata, psym=1
stop
      endelse


      if keyword_set(psname) then begin
         !p.font=-1
         !p.multi=0
         device, /close
         device, encapsulated=0
         set_plot, mydevice
      endif
   endif

endfor

;; print all the parameters, determinant, and the chi^2
if ss.debug or ss.verbose then printandlog, string(pars, determinant, -0.5d0*chi2, format='(' + strtrim(n_elements(pars)+2,2) + '(f0.8,x))'),ss.logname

;printandlog, string(pars, ss.planet.omegadeg.value, determinant, chi2, format='(' + strtrim(n_elements(pars)+3,2) + '(f0.8,x))'),ss.logname

;; if this stop is triggered, you've found a bug!!
if ~finite(chi2) then begin
   printandlog, "You've found a bug! Usually this is triggered by runaway parameters that are not constrained by the data or priors. Re-running with /DEBUG and /VERBOSE flags may help track it down, and please email jason.eastman@cfa.harvard.edu to fix the underlying problem.", ss.logname
   stop
endif

return, chi2

end

