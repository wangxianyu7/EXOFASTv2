;----------------------------------------------------------------------
; 0) TSUM for trapezoid integration (same as before):
;----------------------------------------------------------------------
FUNCTION TSUM, x, y
    n = N_ELEMENTS(x)
    IF n NE N_ELEMENTS(y) THEN MESSAGE, 'TSUM error: x and y size differ.'
    IF n LT 2 THEN RETURN, 0.0D
    
    total = 0.0D
    FOR i=0L, n - 2 DO BEGIN
        dx = x[i+1] - x[i]
        total = total + 0.5D * (y[i] + y[i+1]) * dx
    ENDFOR
    RETURN, total
END

;----------------------------------------------------------------------
; 1) ThetaTilde (no integration needed):
;----------------------------------------------------------------------
FUNCTION ThetaTilde, sigma, zeta, cosTheta, sinTheta
    RETURN, 0.5 * (EXP(-(!PI * zeta * cosTheta * sigma)^2) + $
                   EXP(-(!PI * zeta * sinTheta * sigma)^2))
END

;----------------------------------------------------------------------
; 2) Mtilde_discrete: integrates from t=0..1 via summation:
;----------------------------------------------------------------------
FUNCTION Mtilde_discrete, sigma, u1, u2, zeta, vsini
    NT = 1000
    t_space = FINDGEN(NT+1) / FLOAT(NT)  ; 0..1 in 1001 steps
    
    y = DBLARR(NT+1)
    FOR i=0, NT DO BEGIN
        t = t_space[i]
        term1 = 1.0 - u1*(1.0 - SQRT(1.0 - t^2)) - $
                u2*(1.0 - SQRT(1.0 - t^2))^2
        term2 = 1.0 - u1/3.0 - u2/6.0
        term3 = EXP(-!PI^2 * zeta^2 * sigma^2 * (1.0 - t^2)) + $
                EXP(-!PI^2 * zeta^2 * sigma^2 * t^2)
        term4 = BESELJ(2.0 * !PI * sigma * vsini * t, 0)
        
        y[i] = (term1 / term2) * term3 * term4 * t
    ENDFOR
    
    RETURN, TSUM(t_space, y)
END

;----------------------------------------------------------------------
; 3) DeltaNuFunction_discrete: single-value version
;    Integrates numerator & denominator over sigma=0..4.5
;----------------------------------------------------------------------
FUNCTION DeltaNuFunction_discrete, f, beta, vp, gamma, vsini, u1, u2, zeta, cosTheta, sinTheta
    NSIG = 200
    sigma_space = FINDGEN(NSIG+1) / FLOAT(NSIG) * 1.0
    
    numeratorArr   = DBLARR(NSIG+1)
    denominatorArr = DBLARR(NSIG+1)
    
    FOR i=0, NSIG DO BEGIN
        sigmaVal = sigma_space[i]
        M_sigma  = Mtilde_discrete(sigmaVal, u1, u2, zeta, vsini)
        expFact  = EXP(-2.0*!PI^2.0*beta^2.0*sigmaVal^2 - 4.0*!PI*gamma*sigmaVal)
        ThetaVal = ThetaTilde(sigmaVal, zeta, cosTheta, sinTheta)
        
        numeratorArr[i] = expFact * M_sigma * ThetaVal * $
                          SIN(2.0*!PI*sigmaVal*vp) * sigmaVal
        
        denominatorArr[i] = expFact * M_sigma * $
                            (M_sigma - f * ThetaVal * $
                            COS(2.0*!PI*sigmaVal*vp)) * (sigmaVal^2)
        ; print, i, expFact, M_sigma, ThetaVal, f, vp, sigmaVal
    ENDFOR
    numerator   = TSUM(sigma_space, numeratorArr)
    denominator = TSUM(sigma_space, denominatorArr)
    ; print, i,-f / (2.0 * !PI) * (numerator / denominator) * 1.0E3
    RETURN, -f / (2.0 * !PI) * (numerator / denominator) * 1.0E3
END

;----------------------------------------------------------------------
; 4) DeltaNuFunction_discrete_array:
;    Vectorized version for arrays f[i], vp[i], cosTheta[i], sinTheta[i].
;    We assume all are the same length n.
;----------------------------------------------------------------------
FUNCTION DeltaNuFunction_discrete_array, farr, beta, vparr, gamma, vsini, u1, u2, zeta, cosThArr, sinThArr
    n = N_ELEMENTS(farr)
    IF (n NE N_ELEMENTS(vparr)) THEN MESSAGE, 'f and vp arrays differ in length!'
    IF (n NE N_ELEMENTS(cosThArr)) THEN MESSAGE, 'cosTheta array length mismatch!'
    IF (n NE N_ELEMENTS(sinThArr)) THEN MESSAGE, 'sinTheta array length mismatch!'
    
    ; Prepare an output array
    result = DBLARR(n)
    
    ; Loop over each index
    FOR i=0L, n-1 DO BEGIN
        if sinThArr[i] GT 1.0 THEN BEGIN
            result[i] = 0.0
        endif else begin

            result[i] = DeltaNuFunction_discrete( farr[i], beta, vparr[i], gamma, vsini, $
                                              u1, u2, zeta, cosThArr[i], sinThArr[i] )
            print, i, result[i]
        endelse
       ; print, i, result[i], farr[i], beta, vparr[i], gamma, vsini, u1, u2, zeta, cosThArr[i], sinThArr[i]
    ENDFOR
    
    RETURN, result
END

;----------------------------------------------------------------------
; 5) The rest of your functions (no integration)
;----------------------------------------------------------------------
FUNCTION vpFunction, vsini, RpRs, x_p, y_p
    gridSize = 1000
    dx = 2.0 / gridSize
    dy = 2.0 / gridSize

    xTemp = FINDGEN(gridSize) / (gridSize - 1.0) * 2.0 - 1.0
    x = REBIN(xTemp, gridSize, gridSize)
    y = REFORM(TRANSPOSE(x))

    visibility = shadedRegion(x, y, RpRs, x_p, y_p)
    numerator = TOTAL(x * visibility) * dx * dy
    denominator = TOTAL(visibility) * dx * dy

    IF ABS(denominator) LT 1.0e-10 THEN RETURN, 0.0
    RETURN, vsini * (numerator / denominator)
END

FUNCTION shadedRegion, x, y, RpRs, x_p, y_p
    stellarDisk = ((x^2) + (y^2)) LE 1.0
    planetDisk  = ((x - x_p)^2 + (y - y_p)^2) LE RpRs^2
    RETURN, stellarDisk AND planetDisk
END

FUNCTION computeGamma, r, RpRs
    IF r GT (1.0 + RpRs) THEN RETURN, 0.0
    IF r LE ABS(1.0 - RpRs) THEN RETURN, RpRs^2

    cos_alpha = (1.0 + r^2 - RpRs^2) / (2.0*r)
    cos_beta  = (RpRs^2 + r^2 - 1.0) / (2.0*RpRs*r)

    cos_alpha = MAX(-1.0, MIN(1.0, cos_alpha))
    cos_beta  = MAX(-1.0, MIN(1.0, cos_beta))

    alpha = ACOS(cos_alpha)
    beta  = ACOS(cos_beta)

    S = alpha - 0.5*SIN(2.0*alpha) + RpRs^2*(beta - 0.5*SIN(2.0*beta))
    RETURN, S / !PI 
END







FUNCTION exofast_rossiter, time, inc_rad, ar, TPeriastron, period, e, omega_rad, p, u1, u2, lambda, vsini, $
         vbeta, vgamma, vzeta, vxi, valpha, $ 
         exptime=exptime, ninterp=ninterp, rmmodel=rmmodel
    ; name: exofast_rossiter
    ; purpose: calculate the radial velocity anomaly due to the Rossiter-McLaughlin effect: Ohta2005, Hirano2010, Hirano2011
    ; inputs:
    ;       time: time array in BJD
    ;       inc_rad: inclination angle in radians
    ;       ar: a/Rs
    ;       tc: time of conjunction
    ;       period: orbital period
    ;       e: eccentricity
    ;       omega_rad: argument of periastron in radians
    ;       p: planet to star radius ratio
    ;       u1: limb darkening parameter 1
    ;       u2: limb darkening parameter 2
    ;       lambda: sky-projected angle between the stellar spin and the planetary orbit
    ;       vsini: projected stellar rotational velocity
    
    ;       vbeta: the Guassian dispersion of spectral lines in m/s, typically 2500 - 4500 m/s (see Hirano+11)
    ;       vgamma: the Lorentzian dispersion of spectral lines in m/s, typically 500-1500 m/s (see Hirano+11)
    ;       zeta: the macroturbulence dispersion in m/s, typically 2000 - 6500 km/s (see Hirano+11)

    ;       exptime: exposure time in minutes
    ;       ninterp: number of points to interpolate
    ;       ohta2005: set to 1 to use Ohta+2005 model
    ;       hirano2010: set to 1 to use Hirano+2010 model
    ;       hirano2011: set to 1 to use Hirano+2011 model
    ;       if none of the models are set, Hirano+2011 model is used by default
    ; outputs:
    ;       delta_rv: radial velocity anomaly in m/s
    
   
    
    COMPILE_OPT IDL2
    ; IF (N_ELEMENTS(ohta2005) EQ 0) AND (N_ELEMENTS(hirano2010) EQ 0) AND (N_ELEMENTS(hirano2011) EQ 0) THEN hirano2011 = 1
    IF rmmodel EQ 'ohta2005' THEN ohta2005 = 1
    IF rmmodel EQ 'hirano2010' THEN hirano2010 = 1
    IF rmmodel EQ 'hirano2011' THEN hirano2011 = 1
    IF rmmodel EQ '' THEN hirano2011 = 1

    vsini = vsini / 1000D0
    vbeta = vbeta / 1000D0
    vgamma = vgamma / 1000D0
    vzeta = vzeta / 1000D0
    vxi = vxi / 1000D0
    valpha = valpha / 1000D0
    ; Get the number of points
    npoints = N_ELEMENTS(time)
    IF N_ELEMENTS(ninterp) EQ 0 THEN ninterp = 1

    ; force supersampling to be an integer

    exptime = abs(median(ts_diff(time,1)))*24*60D0
    IF exptime LT 3 THEN BEGIN
        ninterp = 0
    ENDIF ELSE BEGIN
        ninterp = ROUND(exptime/2D0)
    ENDELSE


    ; Interpolate if ninterp is greater than 1
    IF ninterp GT 1 THEN BEGIN
        transitbjd = time # (DBLARR(ninterp) + 1D0) + $
                     ((DINDGEN(ninterp) / ninterp - (ninterp - 1D0) / (2D0 * ninterp)) / $
                     1440D0 * exptime) ## (DBLARR(npoints) + 1D0)
        modelflux = DBLARR(npoints, ninterp) + 1D0
    ENDIF ELSE BEGIN
        transitbjd = time
        modelflux = DBLARR(npoints) + 1D0
    ENDELSE
    ; Calculate tp using exofast_getphase function
    ; tp = tc - period * exofast_getphase(e, omega_rad, /pri)
    
    ; Get the model flux using exofast_tran function

    tmpmodelflux = exofast_tran(time, inc_rad, ar, TPeriastron, period, e, omega_rad, p, u1, u2, 1)

    ; Calculate phase and true anomaly
    ;phase = exofast_getphase(e, omega_rad, /pri)
    ; Tperiastron = tc - period * phase
    meananom = 2.D0 * !dpi * (1.D0 + (transitbjd - Tperiastron) / Period MOD 1)
    eccanom = exofast_keplereq(meananom, e)
    trueanom = 2.D0 * ATAN(SQRT((1.D0 + e) / (1.D0 - e)) * TAN(eccanom / 2.D0))
    
    ; Calculate coordinates as seen from observer
    ;r = ar*(1d0-e^2)/(1d0+e*cos(trueanom))
    ;print,true
    ;x = - r* COS(trueanom + omega_rad)
    ;y = - r* SIN(trueanom + omega_rad) * COS(inc_rad)
    cosi = COS(inc_rad)
    ; Calculate up, and vp values
    z = exofast_getb2(time, i=inc_rad, a=ar, tperiastron=TPeriastron, period=period, e=e,omega=omega_rad,z2=depth, x2=xp,y2=yp)
    up = xp*cos(lambda) - yp*sin(lambda)
    vp = vsini * up

    ; Compute flux and ratios
    cosTheta = SQRT(1 - xp^2 - yp^2)
    sinTheta = SQRT(xp^2 + yp^2)
    f = 1 - tmpmodelflux
    ratios = DBLARR(npoints)
    IF vsini lt 1 THEN BEGIN
        ; PRINT, 'Error: vsini cannot be zero'
        RETURN, f*0
    ENDIF
    IF KEYWORD_SET(ohta2005) THEN BEGIN
        ; PRINT, 'Using ohta2005 model'
		; Ohta+2005 (OTS)
		delta_rv = - f / (1 - f) * vp * 1E3
    ENDIF ELSE IF KEYWORD_SET(hirano2010) THEN BEGIN
        ; PRINT, 'Using hirano2010 model'
        ;Hirano+2010
        sigma = vsini/1.31 ; Gaussian broadening kernel from Hirano+10. Hirano+10 found vsini/1.31 as an approximation that sometimes works
        vbeta_p_2 = vbeta^2
        vbeta_star_2 = vbeta^2 + sigma^2

        ; Calculate terms
        term1 = (2 * vbeta_star_2) / (vbeta_p_2 + vbeta_star_2)
        term2 = f * vp
        term3 = (1 - (vp^2) / (vbeta_p_2 + vbeta_star_2) + (vp^4) / (2 * (vbeta_p_2 + vbeta_star_2)^2))

        ; Calculate delta_v
        delta_rv = - (term1^(3/2)) * term2 * term3 * 1E3
    ENDIF ELSE IF KEYWORD_SET(hirano2011) THEN BEGIN
        ; PRINT, 'Using hirano2011 model'
        ; Call compute_integral to calculate ratios Hirano+ 2011
        ; ratios = compute_integral( costheta, sintheta, f, vp, u1, u2, vsini, vbeta, vgamma, zeta)
        ; Calculate delta_rv
        ; delta_rv = -f * ratios / (2 * !pi) * 1E3
        ; DeltaNuFunction_discrete_array, farr, beta, vparr, gamma, vsini, u1, u2, zeta, cosThArr, sinThArr
		delta_rv = DeltaNuFunction_discrete_array(f, vbeta, vp, vgamma, vsini, u1, u2, vzeta, cosTheta, sinTheta)
    ENDIF ELSE BEGIN
        PRINT, 'Error: No model specified'
    ENDELSE
    ; result = DeltaNuFunction_discrete_array( farr, beta, vparr, gamma, vsini, $
    ; u1, u2, zeta, cosThArr, sinThArr )
    RETURN, delta_rv
END

